<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="keywords" data-name="fire" content="JavaScript,Vue.js,小程序,WebPack,ECMAScript 6,vue,php,js,JavaScript,typescirpt,node,egg,很帅很愁人,web前端,全栈,网页,博客，前端博客,JavaScript,html5,css3,Jquery,NodeJs
"><meta name="360-site-verification" content="178e3a7a27a16a1253976882a4d99509"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/fly-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/fly-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="iy8yHMd-90Qb6NAJqgoij_Cz3i3Jh9FRGRxrWJbRrOw"><meta name="msvalidate.01" content="92E59C28288B8049A45C6288AD39DFA0"><meta name="baidu-site-verification" content="code-etAIIwOVpZ"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.wy1991.cn",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!0,sidebar:{position:"left",display:"hide",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="vue react 常见面试题"><meta property="og:type" content="article"><meta property="og:title" content="169-vue-react面试专栏"><meta property="og:url" content="https://blog.wy1991.cn/20220219/169-vue-react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><meta property="og:site_name" content="很帅很愁人~"><meta property="og:description" content="vue react 常见面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a8d50844e2e432583bc594698c9418d~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bb096d0622b42809b1841031af29ced~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0176b2c3d543af923576b19e09c535~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03b13210426f4a1a9522ae7381ed7992~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2f2b132bed14d9db214edc36ef426a4~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c249c931ca3e4bbf9187610c14a83653~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de75972691ff4388b1f683960e00dc3a~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a093675cbac04e02a17459088c846ae7~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc4e0ed50c54cffaeaf1557b482464a~tplv-k3u1fbpfcp-watermark.awebp"><meta property="article:published_time" content="2022-02-19T00:37:01.000Z"><meta property="article:modified_time" content="2022-02-19T00:38:25.370Z"><meta property="article:author" content="很帅很愁人~"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a8d50844e2e432583bc594698c9418d~tplv-k3u1fbpfcp-watermark.awebp"><link rel="canonical" href="https://blog.wy1991.cn/20220219/169-vue-react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>169-vue-react面试专栏 | 很帅很愁人~</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script src="/js/fairyDustCursor.js"></script><script src="/js/clickLove.js"></script></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">很帅很愁人~</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">迷茫是因为才华配不上梦想の，所以你必须非常努力，才能显得毫不费力！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-学习"><a href="/19410322/999999-%E6%9C%89%E7%82%B9%E5%A5%BD%E7%8E%A9/" rel="section"><i class="fa fa-calendar fa-fw"></i>学习</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.wy1991.cn/20220219/169-vue-react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/my.jpg"><meta itemprop="name" content="很帅很愁人~"><meta itemprop="description" content="梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="很帅很愁人~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">169-vue-react面试专栏</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-19 08:37:01 / 修改时间：08:38:25" itemprop="dateCreated datePublished" datetime="2022-02-19T08:37:01+08:00">2022-02-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><div class="post-description" style="opacity:0">vue react 常见面试题</div></div></header><div class="post-body" itemprop="articleBody"><p>适合初次全面复习的同学，查缺补漏，知识面比较全，复习完成后，再按照本人整理的面试高频题配合复习，使得找工作事半功倍，一定要理解，不要死记硬背，对于一些概念性的和原理的内容要深入理解。</p><blockquote><p>“你从头读，尽量往下读，直到你一窍不通时，再从头开始，这样坚持往下读，直到你完全读懂为止。”</p></blockquote><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="说说你对-Vue-的理解"><a href="#说说你对-Vue-的理解" class="headerlink" title="说说你对 Vue 的理解"></a>说说你对 Vue 的理解</h3><p>Vue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视图更新。</p><p>优点：<br>1、<code>数据驱动视图</code>，对真实 dom 进行抽象出 virtual dom， 并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新 dom，渲染页面<br>2、由于<code>采用虚拟 dom</code>，但让 Vue ssr 先天不足<br>3、<code>生命周期钩子函数</code>，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然 有优化空间（Vue3 composition-api）<br>4、<code>强大且丰富的 API</code> 提供一系列的 api 能满足业务开发中各类需求<br>5、<code>组件化</code>，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文 件里编写 html\css\js 并且配合 Vue-loader 之后，支持更强大的预处理器等功能<br>6、<code>生态好</code>，社区活跃</p><p>缺点：<br>1、由于<code>底层基于 Object.defineProperty 实现响应式</code>，而这个 api 本身不支持 IE8 及以下浏览器<br>2、csr 的先天不足，首屏性能问题（白屏）seo 不友好</p><h3 id="使用框架一定比原生的或者-jQuery-好吗？为什么"><a href="#使用框架一定比原生的或者-jQuery-好吗？为什么" class="headerlink" title="使用框架一定比原生的或者 jQuery 好吗？为什么"></a>使用框架一定比原生的或者 jQuery 好吗？为什么</h3><p><strong>使用框架的优点：</strong><br>用户体验会更好<br>开发效率高，成本降低，便于后期维护<br>采用虚拟 DOM 操作，更新性能更高</p><p><strong>使用框架的缺点：</strong><br>代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。<br>前端框架迭代更新太快，需要时间熟悉</p><h3 id="浅谈-MVC、MVP、MVVM-架构模式的区别和联系"><a href="#浅谈-MVC、MVP、MVVM-架构模式的区别和联系" class="headerlink" title="浅谈 MVC、MVP、MVVM 架构模式的区别和联系"></a>浅谈 MVC、MVP、MVVM 架构模式的区别和联系</h3><h5 id="一、MVC（Model-View-Controller）"><a href="#一、MVC（Model-View-Controller）" class="headerlink" title="一、MVC（Model-View-Controller）"></a>一、MVC（Model-View-Controller）</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，是比较直观的架构模式。</p><ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li><li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li><li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul><p><strong>MVC 的思想</strong>：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来。</p><h4 id="二、MVP（Model-View-Presenter）"><a href="#二、MVP（Model-View-Presenter）" class="headerlink" title="二、MVP（Model-View-Presenter）"></a>二、MVP（Model-View-Presenter）</h4><p>MVP 是把 MVC 中的 Controller 换成了 Presenter（呈现），<code>目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离</code>。</p><h4 id="三、MVVM（Model-View-ViewModel）"><a href="#三、MVVM（Model-View-ViewModel）" class="headerlink" title="三、MVVM（Model-View-ViewModel）"></a>三、MVVM（Model-View-ViewModel）</h4><p>如果说 MVP 是对 MVC 的进一步改进，那么 MVVM 则是思想的完全变革。<code>它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上</code>。</p><h4 id="四、MVVM-与-MVC-的区别"><a href="#四、MVVM-与-MVC-的区别" class="headerlink" title="四、MVVM 与 MVC 的区别"></a>四、MVVM 与 MVC 的区别</h4><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应 Vue 数据驱动的思想）</p><h3 id="简述-MVVM"><a href="#简述-MVVM" class="headerlink" title="简述 MVVM"></a>简述 MVVM</h3><p><strong>什么是 MVVM？</strong></p><p><code>视图模型双向绑定</code>，是<code>Model-View-ViewModel</code>的缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。Model</code>层代表数据模型，<code>View</code>代表 UI 组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。以前是操作 DOM 结构更新视图，现在是<code>数据驱动视图</code>。</p><p>ViewModel 层：做了两件事实现数据的双向绑定 一是将 Model 转化成 View，即将后端传递的数据渲染到页面上。实现的方式是：<code>数据绑定</code>。二是将 View 转化成 Model，即将所看到的页面变化转化成后端的数据。实现的方式是：<code>DOM 事件监听</code>。</p><blockquote><p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明</p></blockquote><p>为什么官方要说 Vue 没有完全遵循 MVVM 思想呢？</p><blockquote><p>严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p></blockquote><p><strong>MVVM 的优点：</strong></p><p>1.<code>低耦合</code>。视图（View）可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变化，当 Model 变化的时候 View 也可以不变； 2.<code>可重用性</code>。你可以把一些视图逻辑放在一个 Model 里面，让很多 View 重用这段视图逻辑。 3.<code>独立开发</code>。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。 4.<code>可测试</code>。</p><h3 id="说说-Vue-的-MVVM-实现原理"><a href="#说说-Vue-的-MVVM-实现原理" class="headerlink" title="说说 Vue 的 MVVM 实现原理"></a>说说 Vue 的 MVVM 实现原理</h3><ol><li><p>Vue 作为 MVVM 模式的实现库的 2 种技术</p><p>a. 模板解析<br>b. 数据绑定</p></li><li><p>模板解析：实现初始化显示</p><p>a. 解析大括号表达式<br>b. 解析指令</p></li><li><p>数据绑定：实现更新显示</p><p>a. 通过数据劫持实现</p></li></ol><p>创建了两种对象 Observer 和 complie，先创建的 Observer，后创建的 complie，observer 是为了监视/劫持 data 中所有层次的属性，同时还为每一种属性创建了另外一种对象 dep，dep 与 data 中的属性一一对应，complie 作用是用来编译模版，初始化界面，调用 update 对象，complie 还为每个表达式创建了对应的 watcher 同时指定了更新节点的回调函数，将 watcher 添加到所有对应的 dep 中。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a8d50844e2e432583bc594698c9418d~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="Vue-底层实现原理"><a href="#Vue-底层实现原理" class="headerlink" title="Vue 底层实现原理"></a>Vue 底层实现原理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue是采用数据劫持结合发布者-订阅者模式的方式，通过<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>define<span class="constructor">Property()</span>来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调</span><br></pre></td></tr></table></figure><p>Vue 是一个典型的 MVVM 框架，模型（Model）只是普通的 javascript 对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观。</p><p><strong>Observer（数据监听器）</strong>: Observer 的核心是通过 Object.defineProprtty()来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter。这时候 Observer 就要通知订阅者，订阅者就是 Watcher</p><p><strong>Watcher（订阅者）</strong>: Watcher 订阅者作为 Observer 和 Compile 之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个 update()方法</li><li>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调</li></ol><p><strong>Compile（指令解析器）</strong>: Compile 主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h3 id="请描述下响应式原理"><a href="#请描述下响应式原理" class="headerlink" title="请描述下响应式原理"></a>请描述下响应式原理</h3><p>响应式数据原理详解 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTM1MzQ0NjA1NDI0NTE3MTI4">传送门<i class="fa fa-external-link-alt"></i></span></p><ul><li>监听 data 变化过程</li><li>组件渲染和更新的流程</li></ul><h3 id="监听-data-变化的核心-API-是什么"><a href="#监听-data-变化的核心-API-是什么" class="headerlink" title="监听 data 变化的核心 API 是什么"></a>监听 data 变化的核心 API 是什么</h3><ul><li>Object.defineProperty</li><li>以及深度监听、监听数组</li><li>有何缺点</li></ul><h3 id="Vue-如何监听数组变化"><a href="#Vue-如何监听数组变化" class="headerlink" title="Vue 如何监听数组变化"></a>Vue 如何监听数组变化</h3><ul><li>Object.defineProperty 不能监听数组变化</li><li>重新定义原型，重写 pushpop 等方法，实现监听</li><li>Proxy 可以原生支持监听数组变化</li></ul><h3 id="双向绑定-v-model-实现原理"><a href="#双向绑定-v-model-实现原理" class="headerlink" title="双向绑定 v-model 实现原理"></a>双向绑定 v-model 实现原理</h3><ul><li>input 元素的 value = this.name</li><li>绑定 input 事件 this.name = $event.target.value</li><li>data 更新触发 re-render</li></ul><p>当一个<strong>Vue</strong>实例创建时，Vue 会遍历 data 选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p><h3 id="如何自己实现一个-v-model"><a href="#如何自己实现一个-v-model" class="headerlink" title="如何自己实现一个 v-model"></a>如何自己实现一个 v-model</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;text&#x27; @input=&quot;</span>$<span class="attr">emit</span>(&#x27;<span class="attr">change</span>&#x27;, $<span class="attr">event.</span> <span class="attr">target.value</span>)&quot;/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">注意</span></span><br><span class="line"><span class="comment">第一，上面使用：value而没用v-model</span></span><br><span class="line"><span class="comment">第二，上面的change和model.event 对应起来即可，名字自己改</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">model</span>:&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">prop</span>: <span class="string">&#x27;text&#x27;</span>, <span class="comment">// 对应到props text</span></span></span><br><span class="line"><span class="javascript">          <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">text</span>: <span class="built_in">String</span></span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">default</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line">&#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">Components</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">Components</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h3><p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步</p><ol><li>将 模板字符串 转换成 element ASTs（解析器）</li><li>对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）</li><li>使用 element ASTs 生成 render 函数代码字符串（代码生成器）</li></ol><p>模板编译原理详解 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTM2MDI0NTMwMDE2MDEwMjc2">传送门<i class="fa fa-external-link-alt"></i></span></p><h3 id="Vue-组件渲染和更新过程"><a href="#Vue-组件渲染和更新过程" class="headerlink" title="Vue 组件渲染和更新过程"></a>Vue 组件渲染和更新过程</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bb096d0622b42809b1841031af29ced~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><ul><li>初始化渲染过程：<ul><li>解析模板为 render 函数（或在开发环境已完成，vue-loader）</li><li>触发响应式，监听 data 属性 getter setter，并作为依赖被 watch 观察起来</li><li>执行 render 函数，生成 vnode，进行 patch（elem，vnode）</li></ul></li><li>更新过程：<ul><li>修改 data，触发 setter（此前在 getter 中已被监听）通过 notify 在属性被访问和修改时通知变化 watch，每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，重新执行 render 函数。</li><li>重新执行 render 函数，生成 newVnode</li><li>patch(vnode, newVnode)</li></ul></li><li>异步渲染：</li></ul><h3 id="怎样理解-Vue-的单向数据流"><a href="#怎样理解-Vue-的单向数据流" class="headerlink" title="怎样理解 Vue 的单向数据流"></a>怎样理解 Vue 的单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h3 id="Vue-事件绑定原理"><a href="#Vue-事件绑定原理" class="headerlink" title="Vue 事件绑定原理"></a>Vue 事件绑定原理</h3><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。如果要在组件上使用原生事件，需要加.native 修饰符，这样就相当于在父组件中把子组件当做普通 html 标签，然后加上原生事件。</p><p>on、on、on、emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器</p><p>手写发布订阅原理 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTUzNDM3NzAwMTAzI2hlYWRpbmctMg==">传送门<i class="fa fa-external-link-alt"></i></span></p><h3 id="说说你对-vue-虚拟-DOM-的理解"><a href="#说说你对-vue-虚拟-DOM-的理解" class="headerlink" title="说说你对 vue 虚拟 DOM 的理解"></a>说说你对 vue 虚拟 DOM 的理解</h3><p><strong>一、什么是 vdom？</strong></p><p>虚拟 Dom 的产生是<code>为减小浏览器频繁的操作 DOM，所产生的性能问题</code>。Vue2 的 Virtual DOM 借鉴了<code>开源库 snabbdom</code> 的实现。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。</p><p>Virtual DOM 是用 JS 对象来模拟真实 DOM 结构，然后用 JS 对象树构建真实的 DOM 树。当状态变更时，重新构建一棵新的对象树，然后新旧树通过 diff 算法进行比较，若存在差异则将差异应用到所构建的真正的树上，视图就更新了。这个比较过程，由原来的查询真实 DOM 树变成查找 js 对象属性，性能开销小了，效率也就高了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p><p><strong>二、为何要用 vdom？</strong></p><p>虚拟 dom 是为了解决浏览器操作真实 dom 带来的性能问题而出现的，将 DOM 操作放在 JS 层，在内存中操作 JS 对象可提高效率。</p><p><strong>三、vdom 核心函数有哪些</strong></p><p>核心函数：<br>h(‘标签名’, {…属性名…}, […子元素…])<br>h(‘标签名’, {…属性名…}, ‘………’)<br>patch(container, vnode)<br>patch(vnode, newVnode)</p><p><strong>四、优点：</strong></p><ol><li><code>保证性能下限</code>： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，即保证性能的下限；</li><li><code>无需手动操作 DOM</code>： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><code>跨平台</code>： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ol><p><strong>五、缺点:</strong></p><ol><li><code>无法进行极致优化</code>： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li><li><code>首屏白屏</code>。首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li><li><code>SEO不友好</code></li></ol><h3 id="请用-vnode-描述一个-DOM-结构"><a href="#请用-vnode-描述一个-DOM-结构" class="headerlink" title="请用 vnode 描述一个 DOM 结构"></a>请用 vnode 描述一个 DOM 结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">p</span>&gt;</span>vdom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;font-size:20px&quot;</span></span></span><br><span class="line"><span class="tag">        &lt;<span class="attr">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Vnode 结构如下： tag、props、children</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:&#x27;div&#x27;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        className:&#x27;container&#x27;,</span><br><span class="line">        id:&#x27;div1&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">    &#123;</span><br><span class="line">        tag: &#x27;p&#x27;,</span><br><span class="line">        children: &#x27;vdom&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        tag:&#x27;ul&#x27;,</span><br><span class="line">        props: &#123; style:&#x27;font-size:<span class="number">20</span>px&#x27;&#125;,</span><br><span class="line">        children:[</span><br><span class="line">            &#123;</span><br><span class="line">                tag: &#x27;li&#x27;</span><br><span class="line">                children: &#x27;a&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="你怎么理解-Vue-中的-diff-算法"><a href="#你怎么理解-Vue-中的-diff-算法" class="headerlink" title="你怎么理解 Vue 中的 diff 算法?"></a>你怎么理解 Vue 中的 diff 算法?</h3><p>简述 diff 算法过程</p><ul><li>patch（elem，vnode）和 patch（vnode，newVnode）</li><li>patchVnode 和 addVnodes 和 removeVnodes</li><li>updateChildren （ key 的重要性）</li></ul><p>在 js 中,渲染真实<code>DOM</code>的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实 DOM, 会引起整个<code>dom树的重绘和重排</code>。那么有没有可能实现只更新我们修改的那一小块 dom 而不要更新整个<code>dom</code>呢？此时我们就需要先根据真实<code>dom</code>生成虚拟<code>dom</code>， 当虚拟<code>dom</code>某个节点的数据改变后会生成有一个新的<code>Vnode</code>, 然后新的<code>Vnode</code>和旧的<code>Vnode</code>作比较，发现有不一样的地方就直接修改在真实 DOM 上，然后使旧的<code>Vnode</code>的值为新的<code>Vnode</code>。</p><p>注意：在<code>采取diff算法比较的时候，只会在同层级进行，不会跨层级比较</code>。 当数据发生改变时，set 方法会让调用 Dep.notify()方法通知所有订阅者 Watcher，订阅者就会调用 patch 函数给真实的 DOM 打补丁，更新响应的试图。</p><p><strong>Diff 对比流程</strong></p><p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实 DOM 打补丁，更新相应的视图。</p><p><strong>Diff 对比的过程</strong></p><p>就是调用<code>patch</code>函数，比较新旧节点，一边比较一边给真实的<code>DOM</code>打补丁。在采取<code>diff</code>算法比较新旧节点的时候，比较只会在同层级进行。 在<code>patch</code>方法中，首先进行树级别的比较, <code>new Vnode</code>不存在就删除 <code>old Vnode</code>, <code>old Vnode</code> 不存在就增加新的<code>Vnode</code>, 都存在就执行 diff 更新,当确定需要执行 diff 算法时，比较两个<code>Vnode</code>，包括三种类型操作：属性更新，文本更新，子节点更新。新老节点均有子节点，则对子节点进行<code>diff</code>操作，调用<code>updatechidren</code> ，如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点 如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点，老新老节点都没有子节点的时候，进行文本的替换</p><p><strong>updateChildren</strong> 是<code>patchVnode</code>里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在<code>updateChildren方法</code>中，采用的是<code>首尾指针法</code>。将<code>Vnode</code>的子节点 Vch 和 oldVnode 的子节点 oldCh 提取出来。 <code>oldCh和vCh</code>各有两个头尾的变量<code>StartIdx和EndIdx</code>，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh和vCh</code>至少有一个已经遍历完了，就会结束比较。</p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk0OTU5OTk4MjgzOTA3MTAy">Vue 的 diff 算法传送门<i class="fa fa-external-link-alt"></i></span></p><h3 id="Vue-的数据为什么频繁变化但只会更新一次"><a href="#Vue-的数据为什么频繁变化但只会更新一次" class="headerlink" title="Vue 的数据为什么频繁变化但只会更新一次"></a>Vue 的数据为什么频繁变化但只会更新一次</h3><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p><p>另外，关于<code>waiting</code>变量，这是很重要的一个标志位，它保证<code>flushSchedulerQueue</code>回调（$nextTick 中执行）允许被置入<code>callbacks</code>一次。</p><p>因为 Vue 的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：</p><p>现在有这样的一种情况，<code>mounted</code>的时候<code>test</code>的值会被循环执行++1000 次。 每次++时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次++都会直接操作 DOM 更新视图，这是非常消耗性能的。 所以 Vue 实现了一个 queue 队列，在下一个 tick（或者是当前 tick 的微任务阶段）统一执行 queue 中 Watcher 的 run。同时，拥有相同 id 的 Watcher 不会被重复加入到该 queue 中去，所以不会执行 1000 次 Watcher 的 run。最终更新视图只会直接将 test 对的 DOM 的 0 变成 1000。 保证更新视图操作 DOM 的动作是在当前栈执行完以后下一个 tick（或者是当前 tick 的微任务阶段）的时候调用，大大优化了性能。</p><p>执行顺序<code>update -&gt; queueWatcher -&gt; 维护观察者队列（重复id的Watcher处理） -&gt; waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick回调数组一次） -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新DOM）-&gt;</code></p><ul><li>Vue 是异步更新 Dom 的，Dom 的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行</li></ul><p>由于 VUE 的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM 完成更新，立即执行<code>nextTick(callback)</code>内的回调。</p><p>vue 和 react 一样，对 dom 的修改都是异步的。它会在队列里记录你对 dom 的操作并进行 diff 操作，后一个操作会覆盖前一个，然后更新 dom。</p><h3 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h3><p><strong>函数式组件与普通组件的区别：</strong></p><p>1.函数式组件需要在声明组件是指定 functional:true 2.不需要实例化，所以没有 this,this 通过 render 函数的第二个参数 context 来代替 3.没有生命周期钩子函数，不能使用计算属性，watch 4.不能通过<code>$emit</code> 对外暴露事件，调用事件只能通过 context.listeners.click 的方式调用外部传入的事件 5.因为函数式组件是没有实例化的，所以在外部通过 ref 去引用组件时，实际引用的是 HTMLElement 6.函数式组件的 props 可以不用显示声明，所以没有在 props 里面声明的属性都会被自动隐式解析为 prop,而普通组件所有未声明的属性都解析到<code>$attrs</code>里面，并自动挂载到组件根元素上面(可以通过 inheritAttrs 属性禁止)</p><p><strong>优点：</strong></p><p>1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰</p><p><strong>使用场景：</strong></p><p>一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件 “高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</p><h3 id="导航钩子有哪些？它们有哪些参数"><a href="#导航钩子有哪些？它们有哪些参数" class="headerlink" title="导航钩子有哪些？它们有哪些参数"></a>导航钩子有哪些？它们有哪些参数</h3><p>导航钩子翻译过来就是路由的生命周期函数(vue-router) 他其实主要分为两种全局和局部</p><p>全局的钩子函数<br>beforeEach：在路由切换开始时调用<br>afterEach：在路由切换离开是调用</p><p>局部到单个路由 beforeEnter</p><p>组件的钩子函数<br>beforeRouterEnter,<br>beforeRouterUpdate,<br>beforeRouterLeave</p><p>to：即将进入的目标对象<br>from：当前导航要高开的导航对象<br>next：是一个函数调用 resolve 执行下一步</p><h3 id="谈谈对-vue-生命周期的理解及每个阶段做的事？"><a href="#谈谈对-vue-生命周期的理解及每个阶段做的事？" class="headerlink" title="谈谈对 vue 生命周期的理解及每个阶段做的事？"></a>谈谈对 vue 生命周期的理解及每个阶段做的事？</h3><p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ul><li><code>create阶段</code>：vue 实例被创建<br><code>beforeCreate</code>: 创建前，此时 data 和 methods 中的数据都还没有初始化<br><code>created</code>： 创建完毕，data 中有值，属性和方法的运算，初始化事件，$el 属性还没有显示出来，未挂载,。</li><li><code>mount阶段</code>： vue 实例被挂载到真实 DOM 节点<br><code>beforeMount</code>：可以发起服务端请求，去数据，在挂载开始之前被调用，相关的 render 函数首次被调用。实例已完成以下的配置:编译模板，把 data 里面的数据和模板生成 html。此时还没有挂载 html 到页面上。<br><code>mounted</code>: 此时可以操作 DOM，在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置:用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。</li><li><code>update阶段</code>：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<br><code>beforeUpdate</code> :更新前，在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br><code>updated</code>：更新后，在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><code>destroy阶段</code>：vue 实例被销毁<br><code>beforeDestroy</code>：在实例销毁之前调用。此时可以手动销毁一些方法，实例仍然完全可用。<br><code>destroyed</code>:销毁后，在实例销毁之后调用。调用后，所有的时间监听器都会被溢出，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>生命周期（父子组件） 父组件 beforeCreate –&gt; 父组件 created –&gt; 父组件 beforeMount –&gt; 子组件 beforeCreate –&gt; 子组件 created –&gt; 子组件 beforeMount –&gt; 子组件 mounted –&gt; 父组件 mounted –&gt;父组件 beforeUpdate –&gt;子组件 beforeDestroy–&gt; 子组件 destroyed –&gt; 父组件 updated</p><p><strong>加载渲染过程</strong> 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p><p><strong>挂载阶段</strong> 父 created-&gt;子 created-&gt;子 mounted-&gt;父 mounted</p><p><strong>父组件更新阶段</strong> 父 beforeUpdate-&gt;父 updated</p><p><strong>子组件更新阶段</strong> 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p><strong>销毁阶段</strong> 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h3 id="何时需要使用-beforeDestory"><a href="#何时需要使用-beforeDestory" class="headerlink" title="何时需要使用 beforeDestory"></a>何时需要使用 beforeDestory</h3><ul><li>解绑自定义事件 event.$off</li><li>清除定时器</li><li>解绑自定义的 DOM 事件，如 window scroll 等</li></ul><h3 id="组件中的-data-为什么是一个函数？"><a href="#组件中的-data-为什么是一个函数？" class="headerlink" title="组件中的 data 为什么是一个函数？"></a>组件中的 data 为什么是一个函数？</h3><ol><li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。这样每复用一次组件，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。</li><li>如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</li></ol><h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能。</p><p><strong>computed：</strong> 是计算属性，是用来声明式的描述一个值依赖了其它的属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<code>computed</code>中的函数必须用<code>return</code>返回最终的结果，它可以设置 getter 和 setter。</p><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；例：购物车商品结算功能</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。当一条数据影响多条数据的时候使用，例：搜索数据</li></ul><h3 id="Watch-的运行原理"><a href="#Watch-的运行原理" class="headerlink" title="Watch 的运行原理"></a>Watch 的运行原理</h3><h3 id="ajax-请求应该放在哪个生命周期"><a href="#ajax-请求应该放在哪个生命周期" class="headerlink" title="ajax 请求应该放在哪个生命周期"></a>ajax 请求应该放在哪个生命周期</h3><ul><li>mounted</li><li>JS 是单线程的，ajax 异步获取数据</li><li>放在 mounted 之前没有用，只会让逻辑更加混乱</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul><li>v-if：判断是否隐藏；</li><li>v-for：数据循环出来；</li><li>v-bind:class：绑定一个属性；</li><li>v-model：实现双向绑定</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0176b2c3d543af923576b19e09c535~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><h3 id="v-model-是什么？有什么用呢？"><a href="#v-model-是什么？有什么用呢？" class="headerlink" title="v-model 是什么？有什么用呢？"></a>v-model 是什么？有什么用呢？</h3><p>v-model 只是语法糖而已，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。相当于 v-bind:value=”xxx” 和 @input，意思是绑定了一个 value 属性的值， 子组件可对 value 属性监听，通过$emit(‘input’, xxx)的方式给父组件通讯。自己实现 v-model 方式的组件也是这样的思路。</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h3 id="Vue-修饰符有哪些"><a href="#Vue-修饰符有哪些" class="headerlink" title="Vue 修饰符有哪些"></a>Vue 修饰符有哪些</h3><p><strong>事件修饰符</strong></p><ul><li>.stop 阻止事件继续传播</li><li>.prevent 阻止标签默认行为</li><li>.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理</li><li>.self 只当在 event.target 是当前元素自身时触发处理函数</li><li>.once 事件将只会触发一次</li><li>.passive 告诉浏览器你不想阻止事件的默认行为</li></ul><p><strong>v-model 的修饰符</strong></p><ul><li>.lazy 通过这个修饰符，转变为在 change 事件再同步</li><li>.number 自动将用户的输入值转化为数值类型</li><li>.trim 自动过滤用户输入的首尾空格</li></ul><h3 id="vue-loader-解释下"><a href="#vue-loader-解释下" class="headerlink" title="vue-loader 解释下"></a>vue-loader 解释下</h3><p>vue-loader 就是一个加载器，能把 vue 组件转化成 javascript 模块 为什么要转译 vue 组件？ 可以动态的渲染一些数据，对三个标签 template(结构)、style(表现)、script(行为)都做了优化，script 中可以直接使用 es6 style 也默认可以使用 sass 并且还给你提供作用域的选择，另外开发阶段还给你提供热加载 还可以如下使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">src</span>=<span class="string">&quot;../hello.vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-show-和-v-if-的区别"><a href="#v-show-和-v-if-的区别" class="headerlink" title="v-show 和 v-if 的区别"></a>v-show 和 v-if 的区别</h3><ul><li>v-show 通过 CSS display 控制显示和隐藏</li><li>v-if 组件真正的渲染和销毁，而不是显示和隐藏</li><li>频繁切换显示状态用 v-show，否则用 v-if</li></ul><h3 id="为什么-v-for-和-v-if-不建议用在一起"><a href="#为什么-v-for-和-v-if-不建议用在一起" class="headerlink" title="为什么 v-for 和 v-if 不建议用在一起"></a>为什么 v-for 和 v-if 不建议用在一起</h3><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费 2.这种场景建议使用 computed，先对数据进行过滤</p><h3 id="v-for-中-key-的作用"><a href="#v-for-中-key-的作用" class="headerlink" title="v-for 中 key 的作用"></a>v-for 中 key 的作用</h3><ul><li><p>必须用 key，且不能是 index 和 random</p></li><li><p>当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“<code>就地复用</code>”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的 key 会造成渲染错误。</p></li><li><p><code>减少渲染次数，提升渲染性能。key</code>的作用主要是为了让 vue 可以区分元素，更高效的对比更新虚拟 DOM;</p></li><li><p>diff 算法中通过 tag 和 key 来判断，是否是 sameNode。从源码中可以知道，Vue 在</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">patch</span></span><br></pre></td></tr></table></figure><p>过程中判断两个节点是否是相同节点时主要判断两者的 key 和元素类型等，因此 key 是一个必要条件，如果不设置 key，它的值就是</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>，则可能永远认为这是两个是同一个节点，只能去做更新操作，这导致了频繁更新元素，使得整个</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">patch</span></span><br></pre></td></tr></table></figure><p>过程比较低效，影响性能;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 咱们来看看sameVnode方法的核心原理代码，就一目了然了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">oldVnode, newVnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    oldVnode.key === newVnode.key &amp;&amp; <span class="comment">// key值是否一样</span></span><br><span class="line">    oldVnode.tagName === newVnode.tagName &amp;&amp; <span class="comment">// 标签名是否一样</span></span><br><span class="line">    oldVnode.isComment === newVnode.isComment &amp;&amp; <span class="comment">// 是否都为注释节点</span></span><br><span class="line">    isDef(oldVnode.data) === isDef(newVnode.data) &amp;&amp; <span class="comment">// 是否都定义了data</span></span><br><span class="line">    sameInputType(oldVnode, newVnode) <span class="comment">// 当标签为input时，type必须是否相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vue-组件的通信-通讯方式"><a href="#vue-组件的通信-通讯方式" class="headerlink" title="vue 组件的通信/通讯方式"></a>vue 组件的通信/通讯方式</h3><ul><li><p>父子组件通信</p><p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code>；或者使用自定义事件 <code>event.$on、event.$off、event.$emit</code>； 获取父子组件实例 <code>parent、children</code> <code>Ref</code> 获取实例的方式调用组件的属性或者方法 父-&gt;子孙 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li><li><p>兄弟组件通信</p><p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p></li><li><p>跨级组件通信</p><p><code>Vuex</code>、<code>$attrs、$listeners Provide、inject</code></p></li></ul><h3 id="v-model-的实现以及它的实现原理吗？"><a href="#v-model-的实现以及它的实现原理吗？" class="headerlink" title="v-model 的实现以及它的实现原理吗？"></a>v-model 的实现以及它的实现原理吗？</h3><ol><li><code>vue</code>中双向绑定是一个指令<code>v-model</code>，可以绑定一个动态值到视图，同时视图中变化能改变该值。<code>v-model</code>是语法糖，默认情况下相于:<code>value和@input</code>。</li><li>使用<code>v-model</code>可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</li><li>通常在表单项上使用<code>v-model</code></li><li>原生的表单项可以直接使用<code>v-model</code>，自定义组件上如果要使用它需要在组件内绑定 value 并处理输入事件</li><li>我做过测试，输出包含<code>v-model</code>模板的组件渲染函数，发现它会被转换为 value 属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是 vue 的编译器完成的。</li></ol><h3 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h3><ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li><li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启 1 个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用；</li><li>比如，我在干什么的时候就会使用 nextTick，传一个回调函数进去，在里面执行 dom 操作即可；</li><li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol><h3 id="nextTick-的实现原理是什么？"><a href="#nextTick-的实现原理是什么？" class="headerlink" title="nextTick 的实现原理是什么？"></a>nextTick 的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。<code>思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。主要使用了宏任务和微任务</code>。根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h3><p>vue 中的插槽是一个非常好用的东西 slot 说白了就是一个占位的 在 vue 当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</p><h3 id="keep-alive-的实现"><a href="#keep-alive-的实现" class="headerlink" title="keep-alive 的实现"></a>keep-alive 的实现</h3><p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><ul><li>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</li><li>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</li><li>keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。</li></ul><p>作用：实现组件缓存，不需要重复渲染 ,保持这些组件的状态，以避免反复渲染导致的性能问题。</p><p>什么时候使用：缓存组件，不需要重复渲染。如有多个静态 Tab 页的切换。优化性能的时候。</p><p>场景：tabs 标签页 后台导航，vue 性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h3 id="多个组件有相同的逻辑，如何抽离？mixin"><a href="#多个组件有相同的逻辑，如何抽离？mixin" class="headerlink" title="多个组件有相同的逻辑，如何抽离？mixin"></a>多个组件有相同的逻辑，如何抽离？mixin</h3><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能<code>抽离公共的业务逻辑</code>，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就可以用 mixin 抽离出来</p><p>mixin 并不是完美的解决方案，会有一些问题,<code>vue3 提出的 Composition API</code>旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】</p><p>场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合</p><p>劣势： 1.变量来源不明确，不利于阅读 2.多 mixin 可能会造成命名冲突<br>3.mixin 和组件可能出现多对多的关系，使得项目复杂度变高</p><h3 id="何时要使用异步组件？"><a href="#何时要使用异步组件？" class="headerlink" title="何时要使用异步组件？"></a>何时要使用异步组件？</h3><ul><li>加载大组件的时候</li><li>路由异步加载的时候</li></ul><h3 id="Vuex-的理解及使用场景"><a href="#Vuex-的理解及使用场景" class="headerlink" title="Vuex 的理解及使用场景"></a>Vuex 的理解及使用场景</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。主要是为了解决组件间状态共享的问题，强调的是数据的集中式管理，每一个 Vuex 应用的核心就是 store（仓库）。用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）</p><ol><li><code>Vuex 的状态存储是响应式的</code>；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新</li><li><code>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation</code>，这样使得我们可以方便地跟踪每一个状态的变化</li></ol><p>Vuex 主要包括以下几个核心模块：</p><ol><li><code>State</code>：定义了应用的状态数据</li><li><code>Getter</code>：在 store 中定义“getter”（可以认为是 store 的计算属性），就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</li><li><code>Mutation</code>：是唯一更改 store 中状态的方法，且必须是同步函数</li><li><code>Action</code>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li><li><code>Module</code>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ol><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03b13210426f4a1a9522ae7381ed7992~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="Vuex-管理状态的机制"><a href="#Vuex-管理状态的机制" class="headerlink" title="Vuex 管理状态的机制"></a>Vuex 管理状态的机制</h3><p>集中式管理 vue 多个组件共享的状态和从后台获取的数据 states 帮助组件管理状态的，基于 state 的还有一个计算属性数据 getters，getters 是从 state 中读取数据并计算的，他们两个的数据都是给组件去读，组件中读取 state 状态数据使用 store.state 或 mapState(),读取计算属性数据也有两个方法是 store.state 或 mapState(),读取计算属性数据也有两个方法是 store.state 或 mapState(),读取计算属性数据也有两个方法是 store.getters 和 mapGetters()；更新状态数据涉及到 actions 和 mutations，通过$store.dispatch 或 mapAction()触发 action 的调用,然后 actions 会通过 commit()触发 mutations 调用，mutations 则直接更新状态；actions 还可以同后台 API 进行双向通信。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2f2b132bed14d9db214edc36ef426a4~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>Vuex 中所有的状态更新的唯一途径都是 mutation，同步操作通过 Action 来提交 mutation 实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p><h3 id="Vuex-中-action-和-mutation-有何区别"><a href="#Vuex-中-action-和-mutation-有何区别" class="headerlink" title="Vuex 中 action 和 mutation 有何区别"></a>Vuex 中 action 和 mutation 有何区别</h3><ul><li>action 中处理异步，mutation 不可以</li><li>mutation 做原子操作</li><li>action 可以整合多个 mutation</li></ul><h3 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h3><p>需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</p><p>推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中。</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>“单向数据流”理念的极简示意：</p><ul><li>state：驱动应用的数据源。</li><li>view：以声明方式将 state 映射到视图 。</li><li>actions：响应在 view 上的用户输入导致的状态变化</li></ul><h4 id="单向数据流过程："><a href="#单向数据流过程：" class="headerlink" title="单向数据流过程："></a>单向数据流过程：</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c249c931ca3e4bbf9187610c14a83653~tplv-k3u1fbpfcp-watermark.awebp" alt="img"> 简单的单向数据流（unidirectional data flow）是指用户访问 View，View 发出用户交互的 Action，在 Action 里对 state 进行相应更新，state 更新后会触发 View 更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p><h3 id="懒加载的原理"><a href="#懒加载的原理" class="headerlink" title="懒加载的原理"></a>懒加载的原理</h3><p><strong>路由懒加载：</strong> 将不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。</p><p>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)。</p><p>第二，在 Webpack 2 中，我们可以使用动态 import 语法来定义代码分块点 (split point)： 结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p><p><strong>图片懒加载原理实现：</strong> getBoundingClientRect DOM 元素包含一个 getBoundingClientRect 方法， 执行该方法返回当前 DOM 节点相关的 Css 边框集合，其中有一个 Top 属性代表当前 DOM 节点距离浏览器窗口顶部的高度，只需判断 top 值是否小于当前浏览器窗口的高度(window.innerHeight),若小于说明已经进入用户视野，然后替换为真正的图片即可 另外使用 getBoundingClientRect 作图片懒加载需要注意三点 1。 因为需要监听 scroll 事件，不停的判断 top 的值和浏览器高度的关系，请对监听事件进行函数节流 2. 当屏幕首次渲染时，不会触发 scroll 事件，请主动调用一次事件处理程序，否则若用户不滚动则首屏的图片会一直使用懒加载的默认图片 3. 当所有需要懒加载 的图片都被加载完，需要移除事件监听，避免不必要的内存占用</p><p>intersectionObserver intersectionObserver 作为一个构造函数，传入一个回调函数作为参数，生成一个实例 observer， 这个实例有一个 observe 方法用来观察指定元素是否进入了用户的可视范围，随即触发传入构造函数中的回调函数 同时给回调函数传入一个 entries 的参数，记录着这个实例观察的所有元素的对象，其中 intersectionRatio 属性表示图片已经进入可视范围百分比，大于 0 表示已经有部分进入了用户视野 此时替换为真实的图片，并且调用实例的 unobtrusive 将这个 img 元素从这个实例的观察列表的去除</p><h3 id="实现双向绑定-Proxy-与-Object-defineProperty-相比优劣如何"><a href="#实现双向绑定-Proxy-与-Object-defineProperty-相比优劣如何" class="headerlink" title="实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?"></a>实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?</h3><ol><li><strong>Object.definedProperty</strong>的作用是劫持一个对象的属性，劫持属性的 getter 和 setter 方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。</li><li><strong>Proxy</strong>会返回一个代理对象，我们只需要操作新对象即可，而 Object.defineProperty 只能遍历对象属性直接修改。</li><li><strong>Object.definedProperty</strong>不支持数组，更准确的说是不支持数组的各种 API，因为如果仅仅考虑 arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种 API。</li><li>尽管 Object.defineProperty 有诸多缺陷，但是其<code>兼容性要好于Proxy</code>。</li></ol><h3 id="Vue-项目中实现路由按需加载（路由懒加载）的-3-中方式："><a href="#Vue-项目中实现路由按需加载（路由懒加载）的-3-中方式：" class="headerlink" title="Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式："></a>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</h3><ol><li>vue 异步组件</li><li>es6 提案的 import()</li><li>webpack 的 require.ensure()</li></ol><h3 id="vue-router-中常用的路由模式实现原理"><a href="#vue-router-中常用的路由模式实现原理" class="headerlink" title="vue-router 中常用的路由模式实现原理"></a>vue-router 中常用的路由模式实现原理</h3><p><strong>hash 模式</strong></p><ol><li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li><li>可以为 hash 的改变添加监听事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, funcRef, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p><blockquote><p>特点：兼容性好但是不美观</p></blockquote><p><strong>history 模式</strong></p><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><blockquote><p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p></blockquote><h3 id="Vue-中的-scoped-实现原理"><a href="#Vue-中的-scoped-实现原理" class="headerlink" title="Vue 中的 scoped 实现原理"></a>Vue 中的 scoped 实现原理</h3><p>一个项目中的所有 style 标签全部<code>加上了scoped，相当于实现了样式的模块化</code>。 vue 中的 scoped 属性的效果主要<code>通过PostCSS转译实现</code>，即：PostCSS 给一个组件中的所有 dom 添加了一个独一无二的动态属性，然后，给 CSS 选择器额外添加一个对应的属性选择器来选择该组件中 dom，这种做法使得样式只作用于含有该属性的 dom——组件内部 dom。</p><h3 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h3><p>1.工厂模式 - 传入参数即可创建实例</p><p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p><p>2.单例模式 - 整个程序有且仅有一个实例</p><p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p><p>3.发布-订阅模式 (vue 事件机制)</p><p>4.观察者模式 (响应式数据原理)</p><p>5.装饰模式: (@装饰器的用法)</p><p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p><h3 id="观察者模式与发布-订阅模式两者的区别"><a href="#观察者模式与发布-订阅模式两者的区别" class="headerlink" title="观察者模式与发布-订阅模式两者的区别"></a>观察者模式与发布-订阅模式两者的区别</h3><p><strong>观察者模式</strong>：允许观察者实例对象(订阅者)执行适当的事件处理程序来注册和接收目标实例对象(发布者)发出的通知（即在观察者实例对象上注册<code>update</code>方法），<code>使订阅者和发布者之间产生了依赖关系</code>，且没有事件通道。不存在封装约束的单一对象，目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。<code>通信只能是单向的</code>。</p><p><strong>发布/订阅模式</strong>：单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。<code>通信可以实现双向</code>。该模式存在不稳定性，发布者无法感知订阅者的状态。</p><h3 id="使用过-Vue-SSR-吗？说说-SSR"><a href="#使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR"></a>使用过 Vue SSR 吗？说说 SSR</h3><p>SSR 也就是<code>服务端渲染</code>，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p><strong>优点：</strong></p><p>SSR 有着更好的 SEO、并且首屏加载速度更快</p><p><strong>缺点：</strong> 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。</p><p>服务器会有更大的负载需求</p><h3 id="你知道-Vue3-有哪些新特性吗？它们会带来什么影响？"><a href="#你知道-Vue3-有哪些新特性吗？它们会带来什么影响？" class="headerlink" title="你知道 Vue3 有哪些新特性吗？它们会带来什么影响？"></a>你知道 Vue3 有哪些新特性吗？它们会带来什么影响？</h3><ul><li><strong>性能提升</strong><ul><li>更小巧、更快速 支持自定义渲染器 支持摇树优化：一种在打包时去除无用代码的优化手段 支持 Fragments 和跨组件渲染</li><li>其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。</li><li><code>静态树提升</code>降低渲染成本</li><li>在设计时也考虑 TypeScript 的类型推断特性 <code>重写虚拟DOM</code>可以期待更多的编译时提示来减少运行时的开销</li></ul></li><li><strong>API 变动</strong><ul><li>响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty,<code>基于Proxy的观察者机制</code>节省内存开销</li><li>组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。</li><li>模板语法变化 slot 具名插槽语法,<code>优化插槽生成</code>可以单独渲染父组件和子组件。 自定义指令 v-model 升级</li></ul></li><li><strong>不兼容 IE11</strong>：<code>检测机制</code>更加全面、精准、高效,更具可调试式的响应跟踪</li></ul><p>Vue3.0 新特性以及使用经验总结 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTQwNDU0NzY0NDIxMzE2NjQ0">传送门<i class="fa fa-external-link-alt"></i></span></p><h3 id="Vue3-0-编译做了哪些优化？"><a href="#Vue3-0-编译做了哪些优化？" class="headerlink" title="Vue3.0 编译做了哪些优化？"></a>Vue3.0 编译做了哪些优化？</h3><p>a. 生成 Block tree Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组 件的整个 vnode 树。在 2.0 里，渲染效率的快慢与组件大小成正相关：组件越大，渲染 效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。 Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的， 每个区块只需要追踪自身包含的动态节点。所以，在 3.0 里，渲染效率不再与模板大小 成正相关，而是与模板中动态节点的数量成正相关。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de75972691ff4388b1f683960e00dc3a~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>b. slot 编译优化 Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组 件 update，造成性能的浪费。 Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更新。 动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产生运行时动 态变化但是又无法被子组件 track 的操作。 c. diff 算法优化</p><h3 id="Vue3-0-是如何变得更快的？（底层，源码）"><a href="#Vue3-0-是如何变得更快的？（底层，源码）" class="headerlink" title="Vue3.0 是如何变得更快的？（底层，源码）"></a>Vue3.0 是如何变得更快的？（底层，源码）</h3><p>a. diff 方法优化 Vue2.x 中的虚拟 dom 是进行全量的对比。 Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。 b. hoistStatic 静态提升 Vue2.x : 无论元素是否参与更新，每次都会重新创建。 Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。 c. cacheHandlers 事件侦听器缓存 默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可。 原作者姓名： 欧阳呀</p><p>2.0 存在的问题 1.对原始数据进行克隆一份 2.需要分别给对象中的每个属性设置监听 3.0 里面使用的是 proxy 监听对象中的所有的属性</p><h3 id="Vue3-0-和-2-0-的响应式原理区别"><a href="#Vue3-0-和-2-0-的响应式原理区别" class="headerlink" title="Vue3.0 和 2.0 的响应式原理区别"></a>Vue3.0 和 2.0 的响应式原理区别</h3><p>Vue3.x 改用 <code>Proxy 替代 Object.defineProperty</code>。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p><h3 id="vue-性能优化的方法-你都做过哪些-Vue-的性能优化？"><a href="#vue-性能优化的方法-你都做过哪些-Vue-的性能优化？" class="headerlink" title="vue 性能优化的方法 你都做过哪些 Vue 的性能优化？"></a>vue 性能优化的方法 你都做过哪些 Vue 的性能优化？</h3><p><strong>编码阶段</strong></p><ul><li><code>尽量减少data中的数据及层次结构</code>，否则性能就会差，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</li><li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li><li><code>v-if 和 v-show 区分使用场景</code>，在更多的情况下，使用 v-if 替代 v-show</li><li><code>computed 和 watch 区分使用场景</code></li><li><code>v-for 遍历必须加 key</code>，key 保证唯一，最好是 id 值，且避免同时使用 v-if</li><li><code>防止内部泄漏，自定义事件、DOM事件及时销毁</code>，组件销毁后把全局变量和事件销毁</li><li><code>使用路由懒加载、异步组件</code></li><li>SPA 页面<code>采用keep-alive缓存组件</code></li><li>使用 vue-loader 在开发环境做模板编译（预编译）</li><li>如果需要使用 v-for 给每项元素绑定事件时使用事件代理</li><li><code>防抖、节流运用</code></li><li>长列表滚动到可视区域动态加载</li><li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li><li><code>第三方模块按需导入</code></li><li>图片懒加载</li><li>使用 服务端渲染 SSR</li></ul><p><strong>SEO 优化</strong>\</p><ul><li>服务端渲染 SSR or 预渲染</li><li>打包优化</li><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用 cdn 加载第三方模块</li><li>多线程打包 happypack</li><li>splitChunks 抽离公共文件</li><li>sourceMap 优化\</li></ul><p><strong>用户体验</strong>\</p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。</li></ul><h3 id="vue-与-React-比较"><a href="#vue-与-React-比较" class="headerlink" title="vue 与 React 比较"></a>vue 与 React 比较</h3><p>相同点：</p><ol><li>都是<code>组件化开发和虚拟DOM(Virtual Dom)</code></li><li>都<code>支持通过props进行父子组件间数据通信</code></li><li>都<code>支持数据驱动视图，不直接操作DOM</code>，更新状态数据界面就自动更新</li><li>都<code>支持服务端渲染SSR</code></li><li>都<code>支持native的方案</code>，React 的 React Native， Vue 的 Weex</li></ol><p>不同点：</p><ol><li>数据绑定：vue 实现了数据的双向绑定，react 的数据流动是单向的</li><li>组件的写法不一样，React 推荐的是 JSX 语法，也就是把 HTML 和 CSS 都写进 JavaScript，即”all in js”;vue 推荐的做法是 webpack+vue+loader 的单文件组件格式，即 html，css，js 写在同一个文件中；</li><li>数据状态管理不同，state 对象在 react 应用中是不可变的，需要使用 setState 方法更新状态；在 vue 中 state 对象不是必须的，数据由 data 属性在 vue 对象中管理</li><li>Virtual Dom 不一样，vue 会跟踪每个组件的依赖关系，不需要重新渲染整个组件树；而对于 react 而言，每当应用的状态改变时，全部的组件都会被渲染，所以 react 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制</li><li>React 严格上只针对 MVC 的 View 层，Vue 则是 MVVM 模式</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="函数式组件使用场景和原理-1"><a href="#函数式组件使用场景和原理-1" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h3><p>函数式组件与普通组件的区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数式组件需要在声明组件是指定 functional:<span class="literal">true</span></span><br><span class="line"><span class="number">2.</span>不需要实例化，所以没有<span class="keyword">this</span>,<span class="keyword">this</span>通过render函数的第二个参数context来代替</span><br><span class="line"><span class="number">3.</span>没有生命周期钩子函数，不能使用计算属性，watch</span><br><span class="line"><span class="number">4.</span>不能通过$emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件</span><br><span class="line"><span class="number">5.</span>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement</span><br><span class="line"><span class="number">6.</span>函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点 1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰</p><p>使用场景：</p><p>一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件</p><p>“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</p><p>相关代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">  <span class="comment">// 带有functional的属性的就是函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> listeners = data.on</span><br><span class="line">data.on = data.nativeOn</span><br><span class="line">installComponentHooks(data) <span class="comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span></span><br></pre></td></tr></table></figure><h3 id="React-组件通信方式"><a href="#React-组件通信方式" class="headerlink" title="React 组件通信方式"></a>React 组件通信方式</h3><p>react 组件间通信常见的几种情况:</p><ul><li><ol><li>父组件向子组件通信</li></ol></li><li><ol><li>子组件向父组件通信</li></ol></li><li><ol><li>跨级组件通信</li></ol></li><li><ol><li>非嵌套关系的组件通信</li></ol></li></ul><h4 id="1）父组件向子组件通信"><a href="#1）父组件向子组件通信" class="headerlink" title="1）父组件向子组件通信"></a>1）父组件向子组件通信</h4><p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用 props 就可以获取到这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;京程一灯&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）子组件向父组件通信"><a href="#2）子组件向父组件通信" class="headerlink" title="2）子组件向父组件通信"></a>2）子组件向父组件通信</h4><p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过 props 调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cb = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      props.callback(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&#x27;京程一灯欢迎你!&#x27;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）跨级组件通信"><a href="#3）跨级组件通信" class="headerlink" title="3）跨级组件通信"></a>3）跨级组件通信</h4><p>即父组件向子组件的子组件通信，向更深层子组件通信。</p><ul><li>使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。</li><li>使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context方式实现跨级组件通信</span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BatteryContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件的子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;(color) =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GrandChild</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）非嵌套关系的组件通信"><a href="#4）非嵌套关系的组件通信" class="headerlink" title="4）非嵌套关系的组件通信"></a>4）非嵌套关系的组件通信</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ul><li><ol><li>可以使用自定义事件通信（发布订阅模式），使用 pubsub-js</li></ol></li><li><ol><li>可以通过 redux 等进行全局状态管理</li></ol></li><li><ol><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ol></li><li><ol><li>也可以 new 一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE 的 eventBus 就是发布订阅模式，是可以在 React 中使用的;</li></ol></li></ul><h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 在<code>React事件当中是异步操作</code></p><p>2.同步情况 如果是在<code>setTimeout事件或者自定义的dom事件</code>中，都是同步的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btnAction = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//不能直接修改state，需要通过setState进行修改</span></span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义dom事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a093675cbac04e02a17459088c846ae7~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">当组件从 <span class="title">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<code>大量的同步计算任务阻塞了浏览器的 UI 渲染</code>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><ul><li>react 内部运转分三层：<ul><li>Virtual DOM 层，描述页面长什么样。</li><li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ul></li></ul><p><code>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。任务的优先级有六种：<ul><li>synchronous，与之前的 Stack Reconciler 操作一样，同步执行</li><li>task，在 next tick 之前执行</li><li>animation，下一帧之前执行</li><li>high，在不久的将来立即执行</li><li>low，稍微延迟执行也没关系</li><li>offscreen，下一次 render 时或 scroll 时才执行</li></ul></li><li>Fiber Reconciler（react ）执行过程分为 2 个阶段：<ul><li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li><li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li></ul></li><li>Fiber 树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</li></ul><p>从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><h3 id="React-和-Vue-在虚拟-DOM-的-diff-算法有什么不同"><a href="#React-和-Vue-在虚拟-DOM-的-diff-算法有什么不同" class="headerlink" title="React 和 Vue 在虚拟 DOM 的 diff 算法有什么不同"></a>React 和 Vue 在虚拟 DOM 的 diff 算法有什么不同</h3><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用 portals 进行创建</p><h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><ul><li>加载大组件的时候</li><li>路由异步加载的时候</li></ul><p>react 中要配合 Suspense 使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"><span class="keyword">const</span> Box = lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Box&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用组件的时候要用suspense进行包裹</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">    &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="React-高阶组件的作用有哪些"><a href="#React-高阶组件的作用有哪些" class="headerlink" title="React 高阶组件的作用有哪些"></a>React 高阶组件的作用有哪些</h3><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3d3LmNuYmxvZ3MuY29tL21lbmdmZi9wLzk2NTcyMzIuaHRtbA==">传送门<i class="fa fa-external-link-alt"></i></span></p><h3 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h3><p>immutable 内部提供的所有数据类型，对其数据进行任意操作，<code>操作得到的结果是修改后的值并且修改后的值是一个新的对象，原来的对象没有发生任何变化</code>。 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpz">immutable.js 文档<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpz">github.com/immutable-j…<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vcmhhZG93LmdpdGh1Yi5pby8yMDE1LzA1LzEwL2ZsdXgtaW1tdXRhYmxlLw==">学习文档<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vcmhhZG93LmdpdGh1Yi5pby8yMDE1LzA1LzEwL2ZsdXgtaW1tdXRhYmxlLw==">rhadow.github.io/2015/05/10/…<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="built_in">Map</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> map2 = map1.set(<span class="string">&#x27;b&#x27;</span>,<span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br><span class="line"><span class="built_in">console</span>.log(map2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vuex-和-redux-之间的区别？"><a href="#vuex-和-redux-之间的区别？" class="headerlink" title="vuex 和 redux 之间的区别？"></a>vuex 和 redux 之间的区别？</h3><p>从实现原理上来说，最大的区别是两点：</p><p><strong>Redux</strong>使用的是不可变数据，而<code>Vuex</code>的数据是可变的。<code>Redux</code>每次都是用新的<code>state</code>替换旧的<code>state</code>，而<code>Vuex</code>是直接修改</p><p><strong>Redux</strong>在检测数据变化的时候，是通过<code>diff</code>的方式比较差异的，而<code>Vuex</code>其实和 Vue 的原理一样，是通过 <code>getter/setter</code>来比较的(如果看<code>Vuex</code>源码会知道，其实他内部直接创建一个<code>Vue</code>实例用来跟踪数据变化)</p><h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是<code>在document处监听所有支持的事件</code>，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <code>event.preventDefault</code>。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc4e0ed50c54cffaeaf1557b482464a~tplv-k3u1fbpfcp-watermark.awebp" alt="react事件绑定原理"></p><h3 id="React-项目中有哪些细节可以优化？实际开发中都做过哪些性能优化"><a href="#React-项目中有哪些细节可以优化？实际开发中都做过哪些性能优化" class="headerlink" title="React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化"></a>React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化</h3><p><strong>编译阶段</strong> -&gt;<br><strong>路由阶段</strong> -&gt;<br><strong>渲染阶段</strong> -&gt;<br><strong>细节优化</strong> -&gt;<br><strong>状态管理</strong> -&gt;<br><strong>海量数据源，长列表渲染</strong></p><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>① include 或 exclude 限制 loader 范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    include: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    <span class="attr">use</span>:[<span class="string">&#x27;happypack/loader?id=babel&#x27;</span>]</span><br><span class="line">    <span class="comment">// loader: &#x27;babel-loader&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② happypack 多进程编译 除了上述改动之外，在 plugin 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多线程编译 */</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">  <span class="attr">loaders</span>: [<span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>③ 缓存 babel 编译过的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaders: [<span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span>]</span><br></pre></td></tr></table></figure><p>④tree Shaking 删除冗余代码</p><p>⑤ 按需加载，按需引入。</p><h4 id="路由懒加载，路由监听器"><a href="#路由懒加载，路由监听器" class="headerlink" title="路由懒加载，路由监听器"></a>路由懒加载，路由监听器</h4><p>asyncRouter 实际就是一个高级组件,将()=&gt;import()作为加载函数传进来，然后当外部 Route 加载当前组件的时候，在 componentDidMount 生命周期函数，加载真实的组件，并渲染组件，我们还可以写针对路由懒加载状态定制属于自己的路由监听器 beforeRouterComponentLoad 和 afterRouterComponentDidLoaded，类似 vue 中 watch $route 功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asyncRouter.js 文件</span></span><br><span class="line"><span class="keyword">const</span> routerObserveQueue = [] <span class="comment">/* 存放路由卫视钩子 */</span></span><br><span class="line"><span class="comment">/* 懒加载路由卫士钩子 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RouterHooks = &#123;</span><br><span class="line">  <span class="comment">/* 路由组件加载之前 */</span></span><br><span class="line">  <span class="attr">beforeRouterComponentLoad</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    routerObserveQueue.push(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;before&#x27;</span>,</span><br><span class="line">      callback,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 路由组件加载之后 */</span></span><br><span class="line">  <span class="function"><span class="title">afterRouterComponentDidLoaded</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    routerObserveQueue.push(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;after&#x27;</span>,</span><br><span class="line">      callback,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 路由懒加载HOC */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">AsyncRouter</span>(<span class="params">loadRouter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Content</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="comment">/* 触发每个路由加载之前钩子函数 */</span></span><br><span class="line">      <span class="built_in">this</span>.dispatchRouterQueue(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123; <span class="attr">Component</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    <span class="function"><span class="title">dispatchRouterQueue</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; history &#125; = <span class="built_in">this</span>.props</span><br><span class="line">      routerObserveQueue.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.type === type) item.callback(history)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state.Component) <span class="keyword">return</span></span><br><span class="line">      loadRouter()</span><br><span class="line">        .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> <span class="built_in">module</span>.default)</span><br><span class="line">        .then(<span class="function">(<span class="params">Component</span>) =&gt;</span></span><br><span class="line">          <span class="built_in">this</span>.setState(&#123; Component &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/* 触发每个路由加载之后钩子函数 */</span></span><br><span class="line">            <span class="built_in">this</span>.dispatchRouterQueue(<span class="string">&#x27;after&#x27;</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; Component &#125; = <span class="built_in">this</span>.state</span><br><span class="line">      <span class="keyword">return</span> Component ? <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AsyncRouter, &#123; RouterHooks &#125; <span class="keyword">from</span> <span class="string">&#x27;./asyncRouter.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; beforeRouterComponentLoad &#125; = RouterHooks</span><br><span class="line"><span class="keyword">const</span> Index = AsyncRouter(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../src/page/home/index&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> List = AsyncRouter(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../src/page/list&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> Detail = AsyncRouter(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../src/page/detail&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> index = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 增加监听函数 */</span></span><br><span class="line">    beforeRouterComponentLoad(<span class="function">(<span class="params">history</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前激活的路由是&#x27;</span>, history.location.pathname)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Meuns</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">index</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;Index&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">list</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">detail</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/*&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/index&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="受控性组件颗粒化-，独立请求服务渲染单元"><a href="#受控性组件颗粒化-，独立请求服务渲染单元" class="headerlink" title="受控性组件颗粒化 ，独立请求服务渲染单元"></a>受控性组件颗粒化 ，独立请求服务渲染单元</h4><p>可控性组件颗粒化，独立请求服务渲染单元是笔者在实际工作总结出来的经验。目的就是避免因自身的渲染更新或是副作用带来的全局重新渲染。</p><h4 id="shouldComponentUpdate-PureComponent-和-React-memo-immetable-js-助力性能调优"><a href="#shouldComponentUpdate-PureComponent-和-React-memo-immetable-js-助力性能调优" class="headerlink" title="shouldComponentUpdate ,PureComponent 和 React.memo ,immetable.js 助力性能调优"></a>shouldComponentUpdate ,PureComponent 和 React.memo ,immetable.js 助力性能调优</h4><p>在这里我们拿<code>immetable.js</code>为例，讲最传统的限制更新方法，第六部分将要将一些避免重新渲染的细节。</p><ol><li>PureComponent 和 React.memo</li></ol><p>React.PureComponent 与 React.Component 用法差不多 ,但 React.PureComponent 通过 props 和 state 的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构(比如对象和数组)，他会浅比较，如果深层次的改变，是无法作出判断的，React.PureComponent 认为没有变化，而没有渲染试图。</p><ol><li>shouldComponentUpdate</li></ol><p>使用 shouldComponentUpdate()以让 React 知道当 state 或 props 的改变是否影响组件的重新 render，默认返回 ture，返回 false 时不会重新渲染更新，而且该方法并不会在初始化渲染或当使用 forceUpdate() 时被调用，通常一个 shouldComponentUpdate 应用是这么写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制状态 仅当`state` 中 `data1` 发生改变的时候，重新更新组件。</span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 当 state 中 data1 发生改变的时候，重新更新组件 */</span></span><br><span class="line">  <span class="keyword">return</span> nextState.data1 !== <span class="built_in">this</span>.state.data1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制props属性 仅当`props` 中 `data2` 发生改变的时候，重新更新组件。</span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 当 props 中 data2发生改变的时候，重新更新组件 */</span></span><br><span class="line">  <span class="keyword">return</span> nextProps.data2 !== <span class="built_in">this</span>.props.data2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>immetable.js</li></ol><p>immetable.js 是 Facebook 开发的一个 js 库，可以提高对象的比较性能，像之前所说的 pureComponent 只能对对象进行浅比较，,对于对象的数据类型,却束手无策,所以我们可以用 immetable.js 配合 shouldComponentUpdate 或者 react.memo 来使用。immutable 中</p><h4 id="合理处理细节问题"><a href="#合理处理细节问题" class="headerlink" title="合理处理细节问题"></a>合理处理细节问题</h4><ul><li>① 绑定事件尽量不要使用箭头函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handerClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">666</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  handerClick1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">777</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">handerClick</span>=<span class="string">&#123;this.handerClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handerClick1&#125;</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无状态组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handerClick1 = useMemo(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">777</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  ) <span class="comment">/* [] 存在当前 handerClick1 的依赖项*/</span></span><br><span class="line">  <span class="keyword">const</span> handerClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">666</span>)</span><br><span class="line">  &#125;, []) <span class="comment">/* [] 存在当前 handerClick 的依赖项*/</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">handerClick</span>=<span class="string">&#123;handerClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handerClick1&#125;</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>② 循环正确使用 key</li></ul><p>无论是<code>react</code> 和 <code>vue</code>,正确使用<code>key</code>,目的就是在一次循环中，找到与新节点对应的老节点，复用节点，节省开销。</p><ul><li>③ 无状态组件<code>hooks-useMemo</code> 避免重复声明。</li><li>④ 懒加载 Suspense 和 lazy</li></ul><h4 id="防止重复渲染"><a href="#防止重复渲染" class="headerlink" title="防止重复渲染"></a>防止重复渲染</h4><ul><li>① 学会使用的批量更新 state</li><li>② 合并 state</li><li>③ useMemo React.memo 隔离单元</li><li>④ ‘取缔’state，学会使用缓存。</li><li>⑤ useCallback 回调</li></ul><h4 id="使用状态管理"><a href="#使用状态管理" class="headerlink" title="使用状态管理"></a>使用状态管理</h4><p>对于不变的数据，多个页面或组件需要的数据，为了避免重复请求,我们可以将数据放在状态管理里面。</p><h4 id="海量数据优化"><a href="#海量数据优化" class="headerlink" title="海量数据优化"></a>海量数据优化</h4><ol><li>时间分片</li></ol><p>时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，<strong>js 执行永远要比 dom 渲染快的多。</strong> ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。</p><p><code>setTimeout</code> 可以用 <code>window.requestAnimationFrame()</code> 代替，会有更好的渲染效果。我们<code>demo</code>使用列表做的，实际对于列表来说，最佳方案是虚拟列表，而时间分片，更适合<strong>热力图，地图点位比较多的情况</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">list</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">  handerClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sliceTime(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40000</span>).fill(<span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sliceTime = <span class="function">(<span class="params">list, times</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (times === <span class="number">400</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newList = list.slice(times, (times + <span class="number">1</span>) * <span class="number">100</span>) <span class="comment">/* 每次截取 100 个 */</span></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">list</span>: <span class="built_in">this</span>.state.list.concat(newList),</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.sliceTime(list, times + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handerClick&#125;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;list.map((item, index) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;item + &#x27;&#x27; + index&#125; Item</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>虚拟列表</li></ol><p><strong>虚拟列表</strong> 是解决长列表渲染的最佳方案。</p><p>为了防止大量<code>dom</code>存在影响性能，我们只对，渲染区和缓冲区的数据做渲染，，虚拟列表区 没有真实的 dom 存在。 缓冲区的作用就是防止快速下滑或者上滑过程中，会有空白的现象。</p><p>虚拟列表是按需显示的一种技术，可以根据用户的滚动，不必渲染所有列表项，而只是渲染可视区域内的一部分列表元素的技术。正常的虚拟列表分为 渲染区，缓冲区 ，虚拟列表区。</p><h4 id="首屏加载："><a href="#首屏加载：" class="headerlink" title="首屏加载："></a>首屏加载：</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-   首屏优化一般涉及到几个指标<span class="constructor">FP(First Paint 首次绘制)</span>、<span class="constructor">FCP(First Contentful Paint 首次有内容的渲染)</span>、<span class="constructor">FMP(First Meaningful Paint 首次有意义的绘制)</span>、<span class="constructor">TTI(Time To <span class="params">interactive</span> 可交互时间)</span>；要有一个良好的体验是尽可能的把FCP提前，需要做一些工程化的处理，去优化资源的加载</span><br><span class="line">-   方式及分包策略，资源的减少是最有效的加快首屏打开的方式；</span><br><span class="line">-   对于CSR的应用，FCP的过程一般是首先加载js与css资源，js在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以CSR可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence与<span class="keyword">lazy</span>做懒加载动态组件的方式</span><br><span class="line">-   当然还有另外一种方式就是<span class="constructor">SSR(服务端渲染)</span>的方式，SSR对于首屏的优化有一定的优势，但是这种瓶颈一般在Node服务端的处理，建议使用stream流的方式来处理，对于体验与node端的内存管理等，都有优势；</span><br><span class="line">-   不管对于<span class="constructor">CSR(客户端渲染)</span>或者<span class="constructor">SSR(服务端渲染)</span>，都建议配合使用Service worker，来控制资源的调配及骨架屏秒开的体验</span><br><span class="line">-   react项目上线之后，首先需要保障的是可用性，所以可以通过React.Profiler分析组件的渲染次数及耗时的一些任务，但是Profile记录的是commit阶段的数据，所以对于react的调和阶段就需要结合performance API一起分析；</span><br><span class="line">-   由于React是父级props改变之后，所有与props不相关子组件在没有添加条件控制的情况之下，也会触发render渲染，这是没有必要的，可以结合React的PureComponent以及<span class="module-access"><span class="module"><span class="identifier">React</span>.</span></span>memo等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用ShouldComponentUpdate做深比较处理；</span><br><span class="line">-   所有的运行状态优化，都是减少不必要的render，<span class="module-access"><span class="module"><span class="identifier">React</span>.</span></span>useMemo与<span class="module-access"><span class="module"><span class="identifier">React</span>.</span></span>useCallback也是可以做很多优化的地方；</span><br><span class="line">-   在很多应用中，都会涉及到使用redux以及使用context，这两个都可能造成许多不必要的render，所以在使用的时候，也需要谨慎的处理一些数据；</span><br><span class="line">-   最后就是保证整个应用的可用性，为组件创建错误边界，可以使用componentDidCatch来处理；</span><br><span class="line">- 使用script 的 async 和 defer 属性，异步加载避免阻塞</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h3><ul><li>Vue-Router 路由懒加载（利用 Webpack 的代码切割）</li><li>使用 CDN 加速，将通用的库从 vendor 进行抽离</li><li>Nginx 的 gzip 压缩</li><li>Vue 异步组件</li><li>服务端渲染 SSR</li><li>如果使用了一些 UI 库，采用按需加载</li><li>Webpack 开启 gzip 压缩</li><li>如果首屏为登录页，可以做成多入口</li><li>Service Worker 缓存文件处理</li><li>使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li></ul><h3 id="hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别"><a href="#hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别" class="headerlink" title="hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别"></a>hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</h3><p>类组件是使用 ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <code>props</code> 对象并返回一个 React 元素。</p><p>关于 React 的两套 API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p><p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p><p><strong>类组件的缺点</strong> :</p><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 <code>this</code> 的工作方式。</p><p><strong>区别</strong>：</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><p>1.状态的有无<br>hooks 出现之前，函数组件<code>没有实例</code>，<code>没有生命周期</code>，<code>没有state</code>，<code>没有this</code>，所以我们称函数组件为无状态组件。 hooks 出现之前，react 中的函数组件通常只考虑负责 UI 的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数 props 决定，不受其他任何因素影响。</p><p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的 react 元素。类组件重新渲染将 new 一个新的组件实例，然后调用 render 类方法返回 react 元素，这也说明为什么类组件中 this 是可变的。</p><p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p><p><strong>React Hooks（钩子的作用）</strong></p><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>React Hooks 的几个常用钩子:</p><ol><li><code>useState()</code> //状态钩子</li><li><code>useContext()</code> //共享状态钩子</li><li><code>useReducer()</code> //action 钩子</li><li><code>useEffect()</code> //副作用钩子</li></ol><p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p><ul><li><p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为 class 组件 render 函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Click happened&#x27;</span>)</span><br><span class="line">  &#125;, []) <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p></li><li><p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p></li><li><p>3.useRef 保存引用值</p><p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p></li><li><p>4.useImperativeHandle 穿透 Ref</p><p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p></li><li><p>5.useLayoutEffect 同步执行副作用</p><p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p><p><strong>useEffect 和 useLayoutEffect 有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect 和原来 componentDidMount&amp;componentDidUpdate 一致，在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码。<code>官方建议优先使用useEffect</code></p></li></ul><h3 id="Composition-API-与-React-js-中-Hooks-的异同点"><a href="#Composition-API-与-React-js-中-Hooks-的异同点" class="headerlink" title="Composition API 与 React.js 中 Hooks 的异同点"></a>Composition API 与 React.js 中 Hooks 的异同点</h3><p>a. React.js 中的 Hooks 基本使用 React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能 用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西 带入组件中。 React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组 件中开始尝试 Hooks，并保持既有组件不做任何更改。 案例： useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和 运行副作用。 我们也可以自定义一个 Hooks，它打开了代码复用性和扩展性的新大门。</p><p>b. Vue Composition API 基本使用 Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了 状态、计算值、watcher 和生命周期钩子。 并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API （向下兼容）。</p><p>c. 原理 React hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行 所有的 hooks。 Vue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响 应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的地 方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能 上的问题）。 React 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注 册一次，所以 React 复杂程度会高一些。 m</p><h3 id="react-最新版本解决了什么问题-加了哪些东西"><a href="#react-最新版本解决了什么问题-加了哪些东西" class="headerlink" title="react 最新版本解决了什么问题 加了哪些东西"></a>react 最新版本解决了什么问题 加了哪些东西</h3><p>React 16.x 的三大新特性 Time Slicing, Suspense，hooks</p><ul><li><ol><li>Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能</li></ol></li><li><ol><li>Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非</li></ol></li><li>的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式</li><li><ol><li>此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。</li></ol></li></ul></div><div class="reward-container"><div>如果觉得文章有帮助，就请吃个雪糕吧~</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/wechatpay.png" alt="很帅很愁人~ 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>很帅很愁人~</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.wy1991.cn/20220219/169-vue-react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="169-vue-react面试专栏">https://blog.wy1991.cn/20220219/169-vue-react常见面试题/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li><li class="post-copyright-license"><strong>联系方式： </strong>如文章有错误，请联系qq：598204996 谢谢~</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js/" rel="tag"># js</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20220219/168-%E6%8E%A8%E8%8D%906%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84CSS-tools/" rel="prev" title="168-推荐6个有意思的CSS tools"><i class="fa fa-chevron-left"></i> 168-推荐6个有意思的CSS tools</a></div><div class="post-nav-item"><a href="/20220219/170-react%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" rel="next" title="170-react中常见动画实现方式">170-react中常见动画实现方式 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue"><span class="nav-number">1.</span> <span class="nav-text">Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-Vue-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">说说你对 Vue 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%86%E6%9E%B6%E4%B8%80%E5%AE%9A%E6%AF%94%E5%8E%9F%E7%94%9F%E7%9A%84%E6%88%96%E8%80%85-jQuery-%E5%A5%BD%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.</span> <span class="nav-text">使用框架一定比原生的或者 jQuery 好吗？为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E8%B0%88-MVC%E3%80%81MVP%E3%80%81MVVM-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">1.3.</span> <span class="nav-text">浅谈 MVC、MVP、MVVM 架构模式的区别和联系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81MVC%EF%BC%88Model-View-Controller%EF%BC%89"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">一、MVC（Model-View-Controller）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81MVP%EF%BC%88Model-View-Presenter%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">二、MVP（Model-View-Presenter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81MVVM%EF%BC%88Model-View-ViewModel%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">三、MVVM（Model-View-ViewModel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81MVVM-%E4%B8%8E-MVC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.3.</span> <span class="nav-text">四、MVVM 与 MVC 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-MVVM"><span class="nav-number">1.4.</span> <span class="nav-text">简述 MVVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-Vue-%E7%9A%84-MVVM-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">说说 Vue 的 MVVM 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">Vue 底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">请描述下响应式原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC-data-%E5%8F%98%E5%8C%96%E7%9A%84%E6%A0%B8%E5%BF%83-API-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.8.</span> <span class="nav-text">监听 data 变化的核心 API 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">Vue 如何监听数组变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-v-model-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.</span> <span class="nav-text">双向绑定 v-model 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-v-model"><span class="nav-number">1.11.</span> <span class="nav-text">如何自己实现一个 v-model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.</span> <span class="nav-text">Vue 模板编译原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.13.</span> <span class="nav-text">Vue 组件渲染和更新过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3-Vue-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.14.</span> <span class="nav-text">怎样理解 Vue 的单向数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="nav-number">1.15.</span> <span class="nav-text">Vue 事件绑定原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-vue-%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.16.</span> <span class="nav-text">说说你对 vue 虚拟 DOM 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%94%A8-vnode-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA-DOM-%E7%BB%93%E6%9E%84"><span class="nav-number">1.17.</span> <span class="nav-text">请用 vnode 描述一个 DOM 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-Vue-%E4%B8%AD%E7%9A%84-diff-%E7%AE%97%E6%B3%95"><span class="nav-number">1.18.</span> <span class="nav-text">你怎么理解 Vue 中的 diff 算法?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%E4%BD%86%E5%8F%AA%E4%BC%9A%E6%9B%B4%E6%96%B0%E4%B8%80%E6%AC%A1"><span class="nav-number">1.19.</span> <span class="nav-text">Vue 的数据为什么频繁变化但只会更新一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.20.</span> <span class="nav-text">函数式组件使用场景和原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="nav-number">1.21.</span> <span class="nav-text">导航钩子有哪些？它们有哪些参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%81%9A%E7%9A%84%E4%BA%8B%EF%BC%9F"><span class="nav-number">1.22.</span> <span class="nav-text">谈谈对 vue 生命周期的理解及每个阶段做的事？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.22.1.</span> <span class="nav-text">组件生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-beforeDestory"><span class="nav-number">1.23.</span> <span class="nav-text">何时需要使用 beforeDestory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.24.</span> <span class="nav-text">组件中的 data 为什么是一个函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.25.</span> <span class="nav-text">computed 和 watch 的区别和运用的场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watch-%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.26.</span> <span class="nav-text">Watch 的运行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax-%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.27.</span> <span class="nav-text">ajax 请求应该放在哪个生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.28.</span> <span class="nav-text">常用指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="nav-number">1.29.</span> <span class="nav-text">v-model 是什么？有什么用呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.30.</span> <span class="nav-text">Vue 修饰符有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-loader-%E8%A7%A3%E9%87%8A%E4%B8%8B"><span class="nav-number">1.31.</span> <span class="nav-text">vue-loader 解释下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-show-%E5%92%8C-v-if-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.32.</span> <span class="nav-text">v-show 和 v-if 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-v-for-%E5%92%8C-v-if-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-number">1.33.</span> <span class="nav-text">为什么 v-for 和 v-if 不建议用在一起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-for-%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.34.</span> <span class="nav-text">v-for 中 key 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1-%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="nav-number">1.35.</span> <span class="nav-text">vue 组件的通信&#x2F;通讯方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model-%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">1.36.</span> <span class="nav-text">v-model 的实现以及它的实现原理吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.37.</span> <span class="nav-text">nextTick 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.38.</span> <span class="nav-text">nextTick 的实现原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%8F%92%E6%A7%BD%E4%B9%88%EF%BC%9F%E7%94%A8%E7%9A%84%E6%98%AF%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E8%BF%98%E6%98%AF%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD%E6%88%96%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="nav-number">1.39.</span> <span class="nav-text">使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keep-alive-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.40.</span> <span class="nav-text">keep-alive 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8A%BD%E7%A6%BB%EF%BC%9Fmixin"><span class="nav-number">1.41.</span> <span class="nav-text">多个组件有相同的逻辑，如何抽离？mixin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.42.</span> <span class="nav-text">何时要使用异步组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.43.</span> <span class="nav-text">Vuex 的理解及使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.44.</span> <span class="nav-text">Vuex 管理状态的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Vuex-%E7%9A%84-mutation-%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%81%9A%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">1.45.</span> <span class="nav-text">为什么 Vuex 的 mutation 中不能做异步操作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-%E4%B8%AD-action-%E5%92%8C-mutation-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">1.46.</span> <span class="nav-text">Vuex 中 action 和 mutation 有何区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.47.</span> <span class="nav-text">Vuex 页面刷新数据丢失怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.48.</span> <span class="nav-text">单向数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.48.1.</span> <span class="nav-text">单向数据流过程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.49.</span> <span class="nav-text">懒加载的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-Proxy-%E4%B8%8E-Object-defineProperty-%E7%9B%B8%E6%AF%94%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95"><span class="nav-number">1.50.</span> <span class="nav-text">实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%EF%BC%88%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%89%E7%9A%84-3-%E4%B8%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.51.</span> <span class="nav-text">Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.52.</span> <span class="nav-text">vue-router 中常用的路由模式实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E4%B8%AD%E7%9A%84-scoped-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.53.</span> <span class="nav-text">Vue 中的 scoped 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.54.</span> <span class="nav-text">vue 中使用了哪些设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.55.</span> <span class="nav-text">观察者模式与发布-订阅模式两者的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87-Vue-SSR-%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4-SSR"><span class="nav-number">1.56.</span> <span class="nav-text">使用过 Vue SSR 吗？说说 SSR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93-Vue3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="nav-number">1.57.</span> <span class="nav-text">你知道 Vue3 有哪些新特性吗？它们会带来什么影响？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue3-0-%E7%BC%96%E8%AF%91%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.58.</span> <span class="nav-text">Vue3.0 编译做了哪些优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue3-0-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E6%9B%B4%E5%BF%AB%E7%9A%84%EF%BC%9F%EF%BC%88%E5%BA%95%E5%B1%82%EF%BC%8C%E6%BA%90%E7%A0%81%EF%BC%89"><span class="nav-number">1.59.</span> <span class="nav-text">Vue3.0 是如何变得更快的？（底层，源码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue3-0-%E5%92%8C-2-0-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB"><span class="nav-number">1.60.</span> <span class="nav-text">Vue3.0 和 2.0 的响应式原理区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95-%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.61.</span> <span class="nav-text">vue 性能优化的方法 你都做过哪些 Vue 的性能优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-%E4%B8%8E-React-%E6%AF%94%E8%BE%83"><span class="nav-number">1.62.</span> <span class="nav-text">vue 与 React 比较</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#React"><span class="nav-number">2.</span> <span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.1.</span> <span class="nav-text">函数式组件使用场景和原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">React 组件通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">1）父组件向子组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">2）子组件向父组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">3）跨级组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E9%9D%9E%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.4.</span> <span class="nav-text">4）非嵌套关系的组件通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setState-%E6%97%A2%E5%AD%98%E5%9C%A8%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5%E4%B9%9F%E5%AD%98%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%83%85%E5%86%B5"><span class="nav-number">2.3.</span> <span class="nav-text">setState 既存在异步情况也存在同步情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.4.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-react-fiber"><span class="nav-number">2.5.</span> <span class="nav-text">说一下 react-fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E8%83%8C%E6%99%AF"><span class="nav-number">2.5.1.</span> <span class="nav-text">1）背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.2.</span> <span class="nav-text">2）实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E5%92%8C-Vue-%E5%9C%A8%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">2.6.</span> <span class="nav-text">React 和 Vue 在虚拟 DOM 的 diff 算法有什么不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Portals"><span class="nav-number">2.7.</span> <span class="nav-text">Portals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%A6%82%E5%92%8C%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">2.8.</span> <span class="nav-text">何时要使用异步组件？如和使用异步组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.9.</span> <span class="nav-text">React 高阶组件的作用有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#immutable-js"><span class="nav-number">2.10.</span> <span class="nav-text">immutable.js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vuex-%E5%92%8C-redux-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">vuex 和 redux 之间的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="nav-number">2.12.</span> <span class="nav-text">React 事件绑定原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%86%E8%8A%82%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%EF%BC%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">2.13.</span> <span class="nav-text">React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="nav-number">2.13.1.</span> <span class="nav-text">编译阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">2.13.2.</span> <span class="nav-text">路由懒加载，路由监听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E6%80%A7%E7%BB%84%E4%BB%B6%E9%A2%97%E7%B2%92%E5%8C%96-%EF%BC%8C%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E6%B8%B2%E6%9F%93%E5%8D%95%E5%85%83"><span class="nav-number">2.13.3.</span> <span class="nav-text">受控性组件颗粒化 ，独立请求服务渲染单元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shouldComponentUpdate-PureComponent-%E5%92%8C-React-memo-immetable-js-%E5%8A%A9%E5%8A%9B%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">2.13.4.</span> <span class="nav-text">shouldComponentUpdate ,PureComponent 和 React.memo ,immetable.js 助力性能调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E7%90%86%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="nav-number">2.13.5.</span> <span class="nav-text">合理处理细节问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%B8%B2%E6%9F%93"><span class="nav-number">2.13.6.</span> <span class="nav-text">防止重复渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">2.13.7.</span> <span class="nav-text">使用状态管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96"><span class="nav-number">2.13.8.</span> <span class="nav-text">海量数据优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="nav-number">2.13.9.</span> <span class="nav-text">首屏加载：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96"><span class="nav-number">2.14.</span> <span class="nav-text">首屏优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E8%81%8A%E8%81%8A-react-%E4%B8%AD-class-%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.15.</span> <span class="nav-text">hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition-API-%E4%B8%8E-React-js-%E4%B8%AD-Hooks-%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">2.16.</span> <span class="nav-text">Composition API 与 React.js 中 Hooks 的异同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react-%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-%E5%8A%A0%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF"><span class="nav-number">2.17.</span> <span class="nav-text">react 最新版本解决了什么问题 加了哪些东西</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="很帅很愁人~" src="/images/my.jpg"><p class="site-author-name" itemprop="name">很帅很愁人~</p><div class="site-description" itemprop="description">梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">218</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">120</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArryaBuffer/" rel="tag">ArryaBuffer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/" rel="tag">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recorder/" rel="tag">Recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/" rel="tag">TS</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/" rel="tag">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/V8/" rel="tag">V8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueRouter/" rel="tag">VueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuex/" rel="tag">Vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebStorage/" rel="tag">WebStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86/" rel="tag">api集中管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apply/" rel="tag">apply</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios/" rel="tag">axios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bind/" rel="tag">bind</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call/" rel="tag">call</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cli/" rel="tag">cli</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cors/" rel="tag">cors</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/" rel="tag">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/drag/" rel="tag">drag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ejsexcel/" rel="tag">ejsexcel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/element/" rel="tag">element</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel%E5%AF%BC%E5%87%BA/" rel="tag">excel导出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filter/" rel="tag">filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/" rel="tag">flex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getters/" rel="tag">getters</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/host/" rel="tag">host</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/" rel="tag">html5</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jenkins/" rel="tag">jenkins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">83</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag">js基础语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%93%8D%E4%BD%9C%E7%AC%A6/" rel="tag">js操作符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/" rel="tag">lottie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/" rel="tag">media</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/messageChannel/" rel="tag">messageChannel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/miniVue/" rel="tag">miniVue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitt/" rel="tag">mitt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/" rel="tag">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nest/" rel="tag">nest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/print/" rel="tag">print</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/" rel="tag">promise</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recorder/" rel="tag">recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ref/" rel="tag">ref</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rem/" rel="tag">rem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/require-context/" rel="tag">require.context</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reuqest/" rel="tag">reuqest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scss/" rel="tag">scss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sessionStorage/" rel="tag">sessionStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot/" rel="tag">slot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stackoverflow/" rel="tag">stackoverflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tailwind/" rel="tag">tailwind</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/" rel="tag">tcp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/" rel="tag">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/three/" rel="tag">three</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/utils/" rel="tag">utils</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vueRouter/" rel="tag">vueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex/" rel="tag">vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vw/" rel="tag">vw</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-worker/" rel="tag">web worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E6%89%93%E5%8D%B0/" rel="tag">web打印</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/worker/" rel="tag">worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlsx/" rel="tag">xlsx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yarn/" rel="tag">yarn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%BF%83/" rel="tag">初心</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB%E5%BA%93/" rel="tag">动画库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型与原型链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" rel="tag">发布订阅</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">多文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B1%8F/" rel="tag">大屏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" rel="tag">媒体查询</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/" rel="tag">字节序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/" rel="tag">封装请求</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/" rel="tag">居中对齐</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E5%BE%97/" rel="tag">心得</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/" rel="tag">性能监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%96%E6%8B%BD/" rel="tag">拖拽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E6%A7%BD/" rel="tag">插槽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B8%E5%86%8C/" rel="tag">相册</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="tag">移动端常见问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/" rel="tag">脚手架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" rel="tag">自动化部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" rel="tag">自适应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E8%AF%95/" rel="tag">调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/" rel="tag">辅助工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%99%E4%B8%A4%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE/" rel="tag">这两年做过的物联网项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="tag">进程和线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%83%A8%E7%BD%B2/" rel="tag">部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a><span class="tag-list-count">1</span></li></ul></canvas></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">豫ICP备19017003号-1 </span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://blog.img.wy1991.cn/static/images/ga.png" style="display:inline-block"></div><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">很帅很愁人~</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="/js/local-search.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f65cb40e9a5d20342ae8b58def42ea5f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.name="baidu_tongji";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:null,display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>