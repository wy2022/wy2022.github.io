<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="keywords" data-name="fire" content="JavaScript,Vue.js,小程序,WebPack,ECMAScript 6,vue,php,js,JavaScript,typescirpt,node,egg,很帅很愁人,web前端,全栈,网页,博客，前端博客,JavaScript,html5,css3,Jquery,NodeJs
"><meta name="360-site-verification" content="178e3a7a27a16a1253976882a4d99509"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/fly-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/fly-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="iy8yHMd-90Qb6NAJqgoij_Cz3i3Jh9FRGRxrWJbRrOw"><meta name="msvalidate.01" content="92E59C28288B8049A45C6288AD39DFA0"><meta name="baidu-site-verification" content="code-etAIIwOVpZ"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.wy1991.cn",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!0,sidebar:{position:"left",display:"hide",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一、组件声明在 React 中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义 TS 类型的。"><meta property="og:type" content="article"><meta property="og:title" content="207-如何优雅地在 React 中使用TypeScript"><meta property="og:url" content="https://blog.wy1991.cn/20220325/207-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/index.html"><meta property="og:site_name" content="很帅很愁人~"><meta property="og:description" content="一、组件声明在 React 中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义 TS 类型的。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e833cb140aa41c7a0c38f4216ff5902~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aec80bdbd1a64ad3b2da185657869bdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/439c3eeb15a54a47aea7ccaa6d687e21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6f409391494f51bfb5c3e905f9fc1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10417c4c14704f3eabde9e658535fbc7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be7d97e6011a4e61bc1d18c141a4c4bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1dbae29dbaa45fc96da354807199b6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b4f7d1031e43c2a8194eae2aa15640~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="article:published_time" content="2022-03-25T00:58:46.000Z"><meta property="article:modified_time" content="2022-03-25T01:00:34.564Z"><meta property="article:author" content="很帅很愁人~"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e833cb140aa41c7a0c38f4216ff5902~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><link rel="canonical" href="https://blog.wy1991.cn/20220325/207-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>207-如何优雅地在 React 中使用TypeScript | 很帅很愁人~</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script src="/js/fairyDustCursor.js"></script><script src="/js/clickLove.js"></script></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">很帅很愁人~</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">迷茫是因为才华配不上梦想の，所以你必须非常努力，才能显得毫不费力！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-学习"><a href="/19410322/999999-%E6%9C%89%E7%82%B9%E5%A5%BD%E7%8E%A9/" rel="section"><i class="fa fa-calendar fa-fw"></i>学习</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.wy1991.cn/20220325/207-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/my.jpg"><meta itemprop="name" content="很帅很愁人~"><meta itemprop="description" content="梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="很帅很愁人~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">207-如何优雅地在 React 中使用TypeScript</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-25 08:58:46 / 修改时间：09:00:34" itemprop="dateCreated datePublished" datetime="2022-03-25T08:58:46+08:00">2022-03-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、组件声明"><a href="#一、组件声明" class="headerlink" title="一、组件声明"></a>一、组件声明</h2><p>在 React 中，组件的声明方式有两种：<strong>函数组件</strong>和<strong>类组件，</strong> 来看看这两种类型的组件声明时是如何定义 TS 类型的。</p><h3 id="1-类组件"><a href="#1-类组件" class="headerlink" title="1. 类组件"></a>1. 类组件</h3><p>类组件的定义形式有两种：<code>React.Component&lt;P, S=&#123;&#125;&gt;</code> 和 <code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code>，它们都是泛型接口，接收两个参数，第一个是 props 类型的定义，第二个是 state 类型的定义，这两个参数都不是必须的，没有时可以省略：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.state.count&#125;</span></span><br><span class="line"><span class="xml">        &#123;this.props.name&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p><code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code> 也是差不多的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>React.PureComponent</code>是有第三个参数的，它表示<code>getSnapshotBeforeUpdate</code>的返回值。</p><p>那 PureComponent 和 Component 的区别是什么呢？它们的主要区别是 PureComponent 中的 shouldComponentUpdate 是由自身进行处理的，不需要我们自己处理，所以 PureComponent 可以在一定程度上提升性能。</p><p>有时候可能会见到这种写法，实际上和上面的效果是一样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent, Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">PureComponent</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那如果定义时候我们不知道组件的 props 的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span>&lt;<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">  <span class="attr">internalProp</span>: P</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props: P</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.internalProp = props</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">type</span> IProps = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span><br><span class="line">;&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;React&quot;</span> age=&#123;<span class="number">18</span>&#125; /&gt; <span class="comment">// Success</span></span><br><span class="line">;&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;TypeScript&quot;</span> age=<span class="string">&quot;hello&quot;</span> /&gt; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2. 函数组件"></a>2. 函数组件</h3><p>通常情况下，函数组件我是这样写的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props: IProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>除此之外，函数类型还可以使用<code>React.FunctionComponent&lt;P=&#123;&#125;&gt;</code>来定义，也可以使用其简写<code>React.FC&lt;P=&#123;&#125;&gt;</code>，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示 props 的类型，这个参数不是必须的。它们就相当于这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> React.FC&lt;P = &#123;&#125;&gt; = React.FunctionComponent&lt;P&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终的定义形式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>当使用这种形式来定义函数组件时，props 中默认会带有 children 属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了 Child1 和 Child2 组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Child1 <span class="keyword">from</span> <span class="string">&#x27;./child1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Child2 <span class="keyword">from</span> <span class="string">&#x27;./child2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Child1</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      TypeScript</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Child1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>Child1 组件结构如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Child1: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, children &#125; = props</span><br><span class="line">  <span class="built_in">console</span>.log(children)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello child1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child1</span><br></pre></td></tr></table></figure><p>我们在 Child1 组件中打印了 children 属性，它的值是一个数组，包含 Child2 对象和后面的文本：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e833cb140aa41c7a0c38f4216ff5902~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>使用 React.FC 声明函数组件和普通声明的区别如下：</p><ul><li>React.FC 显式地定义了返回类型，其他方式是隐式推导的；</li><li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；</li><li>React.FC 为 children 提供了隐式的类型（ReactElement | null）。</li></ul><p>那如果我们在定义组件时不知道 props 的类型，只有调用时才知道，那就还是用泛型来定义 props 的类型。对于使用 function 定义的函数组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>&lt;<span class="title">P</span>&gt;(<span class="params">props: P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">type</span> IProps = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span><br><span class="line">;&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;React&quot;</span> age=&#123;<span class="number">18</span>&#125; /&gt; <span class="comment">// Success</span></span><br><span class="line">;&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;TypeScript&quot;</span> age=<span class="string">&quot;hello&quot;</span> /&gt; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>如果使用箭头函数定义的函数组件，直接这样调用时错误的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = &lt;P&gt;(props: P) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	&#123;props&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>必须使用 extends 关键字来定义泛型参数才能被成功解析：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="xml"><span class="tag">&lt;<span class="name">P</span> <span class="attr">extends</span> <span class="attr">any</span>&gt;</span>(props: P) &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line"><span class="xml">  	<span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	&#123;props&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure><h2 id="二、React-内置类型"><a href="#二、React-内置类型" class="headerlink" title="二、React 内置类型"></a>二、React 内置类型</h2><h3 id="1-JSX-Element"><a href="#1-JSX-Element" class="headerlink" title="1. JSX.Element"></a>1. JSX.Element</h3><p>先来看看 JSX.Element 类型的声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">global</span> &#123;</span><br><span class="line">  <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">    <span class="keyword">interface</span> Element <span class="keyword">extends</span> React.ReactElement&lt;any, any&gt; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，JSX.Element 是 ReactElement 的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。</p><p>JSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> ele = React.createElement(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-React-ReactElement"><a href="#2-React-ReactElement" class="headerlink" title="2. React.ReactElement"></a>2. React.ReactElement</h3><p>React 的类型声明文件中提供了 React.ReactElement ＜ T ＞，它可以让我们通过传入＜ T/＞来注解类组件的实例化，它在声明文件中的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReactElement&lt;</span><br><span class="line">  P = any,</span><br><span class="line">  T <span class="keyword">extends</span> string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="attr">type</span>: T</span><br><span class="line">  <span class="attr">props</span>: P</span><br><span class="line">  <span class="attr">key</span>: Key | <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactElement 是一个接口，包含 type,props,key 三个属性值。该类型的变量值只能是两种： null 和 ReactElement 实例。</p><p>通常情况下，函数组件返回 ReactElement（JXS.Element）的值。</p><h3 id="3-React-ReactNode"><a href="#3-React-ReactNode" class="headerlink" title="3. React.ReactNode"></a>3. React.ReactNode</h3><p>ReactNode 类型的声明如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReactText = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> ReactChild = ReactElement | ReactText</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ReactNodeArray <span class="keyword">extends</span> Array&lt;ReactNode&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> ReactFragment = &#123;&#125; | ReactNodeArray</span><br><span class="line"><span class="keyword">type</span> ReactNode = ReactChild | ReactFragment | ReactPortal | <span class="built_in">boolean</span> | <span class="literal">null</span> | <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>可以看到，ReactNode 是一个联合类型，它可以是 string、number、ReactElement、null、boolean、ReactNodeArray。由此可知。ReactElement 类型的变量可以直接赋值给 ReactNode 类型的变量，但反过来是不行的。</p><p>类组件的 render 成员函数会返回 ReactNode 类型的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> component: React.ReactNode&lt;MyComponent&gt; = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> component: React.ReactNode&lt;MyComponent&gt; = <span class="xml"><span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的代码中，给 component 变量设置了类型是 Mycomponent 类型的 react 实例，这时只能给其赋值其为 MyComponent 的实例组件。</p><p>通常情况下，类组件通过 render() 返回 ReactNode 的值。</p><h3 id="4-CSSProperties"><a href="#4-CSSProperties" class="headerlink" title="4. CSSProperties"></a>4. CSSProperties</h3><p>先来看看 React 的声明文件中对 CSSProperties 的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CSSProperties <span class="keyword">extends</span> CSS.Properties&lt;string | number&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The index signature was removed to enable closed typing for style</span></span><br><span class="line"><span class="comment">   * using CSSType. You&#x27;re able to use type assertion or module augmentation</span></span><br><span class="line"><span class="comment">   * to add properties or an index signature of your own.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * For examples and more information, visit:</span></span><br><span class="line"><span class="comment">   * https://github.com/frenic/csstype#what-should-i-do-when-i-get-type-errors</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.CSSProperties 是 React 基于 TypeScript 定义的 CSS 属性类型，可以将一个方法的返回值设置为该类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classNames = <span class="built_in">require</span>(<span class="string">&#x27;./sidebar.css&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  <span class="attr">isVisible</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> divStyle = (props: Props): React.CSSProperties =&gt; (&#123;</span><br><span class="line">  <span class="attr">width</span>: props.isVisible ? <span class="string">&#x27;23rem&#x27;</span> : <span class="string">&#x27;0rem&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SidebarComponent: React.StatelessComponent&lt;Props&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mySidenav&quot;</span> <span class="attr">className</span>=<span class="string">&#123;classNames.sidenav&#125;</span> <span class="attr">style</span>=<span class="string">&#123;divStyle(props)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里 divStyle 组件的返回值就是 React.CSSProperties 类型。</p><p>我们还可以定义一个 CSSProperties 类型的变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divStyle: React.CSSProperties = &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="string">&#x27;11rem&#x27;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="string">&#x27;7rem&#x27;</span>,</span><br><span class="line">  <span class="attr">backgroundColor</span>: <span class="string">`rgb(<span class="subst">$&#123;props.color.red&#125;</span>,<span class="subst">$&#123;props.color.green&#125;</span>, <span class="subst">$&#123;props.color.blue&#125;</span>)`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个变量可以在 HTML 标签的 style 属性上使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;divStyle&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在 React 的类型声明文件中，style 属性的类型如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style?: CSSProperties | <span class="literal">undefined</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、React-Hooks"><a href="#三、React-Hooks" class="headerlink" title="三、React Hooks"></a>三、React Hooks</h2><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><p>默认情况下，React 会为根据设置的 state 的初始值来自动推导 state 以及更新函数的类型：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aec80bdbd1a64ad3b2da185657869bdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>如果已知 state 的类型，可以通过以下形式来自定义 state 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>如果初始值为 null，需要显式地声明 state 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>如果 state 是一个对象，想要初始化一个空对象，可以使用断言来处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = React.useState&lt;IUser&gt;(&#123;&#125; <span class="keyword">as</span> IUser)</span><br></pre></td></tr></table></figure><p>实际上，这里将空对象{}断言为 IUser 接口就是欺骗了 TypeScript 的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user 的值，否则就会报错。</p><p>下面是声明文件中 useState 的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: S | (() =&gt; S)</span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">S</span>&gt;&gt;]</span></span><br><span class="line"><span class="function">// <span class="title">convenience</span> <span class="title">overload</span> <span class="title">when</span> <span class="title">first</span> <span class="title">argument</span> <span class="title">is</span> <span class="title">omitted</span></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * <span class="title">Returns</span> <span class="title">a</span> <span class="title">stateful</span> <span class="title">value</span>, <span class="title">and</span> <span class="title">a</span> <span class="function"><span class="keyword">function</span> <span class="title">to</span> <span class="title">update</span> <span class="title">it</span>.</span></span></span><br><span class="line"><span class="function"><span class="function"> *</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">usestate</span></span></span></span><br><span class="line"><span class="function"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span> = <span class="title">undefined</span>&gt;(<span class="params"></span>): [<span class="title">S</span> | <span class="title">undefined</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">S</span> | <span class="title">undefined</span>&gt;&gt;]</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">/**</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * <span class="title">An</span> <span class="title">alternative</span> <span class="title">to</span> `<span class="title">useState</span>`.</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> *</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * `<span class="title">useReducer</span>` <span class="title">is</span> <span class="title">usually</span> <span class="title">preferable</span> <span class="title">to</span> `<span class="title">useState</span>` <span class="title">when</span> <span class="title">you</span> <span class="title">have</span> <span class="title">complex</span> <span class="title">state</span> <span class="title">logic</span> <span class="title">that</span> <span class="title">involves</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * <span class="title">multiple</span> <span class="title">sub</span>-<span class="title">values</span>. <span class="title">It</span> <span class="title">also</span> <span class="title">lets</span> <span class="title">you</span> <span class="title">optimize</span> <span class="title">performance</span> <span class="title">for</span> <span class="title">components</span> <span class="title">that</span> <span class="title">trigger</span> <span class="title">deep</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * <span class="title">updates</span> <span class="title">because</span> <span class="title">you</span> <span class="title">can</span> <span class="title">pass</span> `<span class="title">dispatch</span>` <span class="title">down</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">callbacks</span>.</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> *</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">usereducer</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> */</span></span></span></span><br></pre></td></tr></table></figure><p>可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。</p><h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h3><p>useEffect 的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe()</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [props.source])</span><br></pre></td></tr></table></figure><p>当函数的返回值不是函数或者 effect 函数中未定义的内容时，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  subscribe()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>TypeScript 就会报错：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/439c3eeb15a54a47aea7ccaa6d687e21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>来看看 useEffect 在类型声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Destructors are only allowed to return void.</span></span><br><span class="line"><span class="keyword">type</span> Destructor = <span class="function">() =&gt;</span> <span class="built_in">void</span> | &#123; [UNDEFINED_VOID_ONLY]: <span class="built_in">never</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> callbacks are _only_ allowed to return either void, or a destructor.</span></span><br><span class="line"><span class="keyword">type</span> EffectCallback = <span class="function">() =&gt;</span> <span class="built_in">void</span> | Destructor</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO (TypeScript 3.0): ReadonlyArray&lt;unknown&gt;</span></span><br><span class="line"><span class="keyword">type</span> DependencyList = ReadonlyArray&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">effect: EffectCallback, deps?: DependencyList</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">// <span class="title">NOTE</span>: <span class="title">this</span> <span class="title">does</span> <span class="title">not</span> <span class="title">accept</span> <span class="title">strings</span>, <span class="title">but</span> <span class="title">this</span> <span class="title">will</span> <span class="title">have</span> <span class="title">to</span> <span class="title">be</span> <span class="title">fixed</span> <span class="title">by</span> <span class="title">removing</span> <span class="title">strings</span> <span class="title">from</span> <span class="title">type</span> <span class="title">Ref</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * `<span class="title">useImperativeHandle</span>` <span class="title">customizes</span> <span class="title">the</span> <span class="title">instance</span> <span class="title">value</span> <span class="title">that</span> <span class="title">is</span> <span class="title">exposed</span> <span class="title">to</span> <span class="title">parent</span> <span class="title">components</span> <span class="title">when</span> <span class="title">using</span></span></span><br><span class="line"><span class="function"> * `<span class="title">ref</span>`. <span class="title">As</span> <span class="title">always</span>, <span class="title">imperative</span> <span class="title">code</span> <span class="title">using</span> <span class="title">refs</span> <span class="title">should</span> <span class="title">be</span> <span class="title">avoided</span> <span class="title">in</span> <span class="title">most</span> <span class="title">cases</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * `<span class="title">useImperativeHandle</span>` <span class="title">should</span> <span class="title">be</span> <span class="title">used</span> <span class="title">with</span> `<span class="title">React</span>.<span class="title">forwardRef</span>`.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span><br><span class="line"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">useimperativehandle</span></span></span><br><span class="line"><span class="function"> */</span></span><br></pre></td></tr></table></figure><p>可以看到，useEffect 的第一个参数只允许返回一个函数。</p><h3 id="3-useRef"><a href="#3-useRef" class="headerlink" title="3. useRef"></a>3. useRef</h3><p>当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref 对象公开的当前属性。当我们使用 useRef 时，需要给其指定类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameInput = React.useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>这里给实例的类型指定为了 input 输入框类型。</p><p>当 useRef 的初始值为 null 时，有两种创建的形式，第一种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameInput = React.useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>)</span><br><span class="line">nameInput.current.innerText = <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>这种形式下，ref1.current 是只读的（read-only），所以当我们将它的 innerText 属性重新赋值时会报以下错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot assign to <span class="string">&#x27;current&#x27;</span> because it is a read-only property.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那该怎么将 current 属性变为动态可变得的，先来看看类型声明文件中 useRef 是如何定义的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): <span class="title">MutableRefObject</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">// <span class="title">convenience</span> <span class="title">overload</span> <span class="title">for</span> <span class="title">refs</span> <span class="title">given</span> <span class="title">as</span> <span class="title">a</span> <span class="title">ref</span> <span class="title">prop</span> <span class="title">as</span> <span class="title">they</span> <span class="title">typically</span> <span class="title">start</span> <span class="title">with</span> <span class="title">a</span> <span class="title">null</span> <span class="title">value</span></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * `<span class="title">useRef</span>` <span class="title">returns</span> <span class="title">a</span> <span class="title">mutable</span> <span class="title">ref</span> <span class="title">object</span> <span class="title">whose</span> `.<span class="title">current</span>` <span class="title">property</span> <span class="title">is</span> <span class="title">initialized</span> <span class="title">to</span> <span class="title">the</span> <span class="title">passed</span> <span class="title">argument</span></span></span><br><span class="line"><span class="function"> * (<span class="params"><span class="string">`initialValue`</span></span>). <span class="title">The</span> <span class="title">returned</span> <span class="title">object</span> <span class="title">will</span> <span class="title">persist</span> <span class="title">for</span> <span class="title">the</span> <span class="title">full</span> <span class="title">lifetime</span> <span class="title">of</span> <span class="title">the</span> <span class="title">component</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * <span class="title">Note</span> <span class="title">that</span> `<span class="title">useRef</span>(<span class="params"></span>)` <span class="title">is</span> <span class="title">useful</span> <span class="title">for</span> <span class="title">more</span> <span class="title">than</span> <span class="title">the</span> `<span class="title">ref</span>` <span class="title">attribute</span>. <span class="title">It</span>’<span class="title">s</span> <span class="title">handy</span> <span class="title">for</span> <span class="title">keeping</span> <span class="title">any</span> <span class="title">mutable</span></span></span><br><span class="line"><span class="function"> * <span class="title">value</span> <span class="title">around</span> <span class="title">similar</span> <span class="title">to</span> <span class="title">how</span> <span class="title">you</span>’<span class="title">d</span> <span class="title">use</span> <span class="title">instance</span> <span class="title">fields</span> <span class="title">in</span> <span class="title">classes</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * <span class="title">Usage</span> <span class="title">note</span>: <span class="title">if</span> <span class="title">you</span> <span class="title">need</span> <span class="title">the</span> <span class="title">result</span> <span class="title">of</span> <span class="title">useRef</span> <span class="title">to</span> <span class="title">be</span> <span class="title">directly</span> <span class="title">mutable</span>, <span class="title">include</span> `| <span class="title">null</span>` <span class="title">in</span> <span class="title">the</span> <span class="title">type</span></span></span><br><span class="line"><span class="function"> * <span class="title">of</span> <span class="title">the</span> <span class="title">generic</span> <span class="title">argument</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span><br><span class="line"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">useref</span></span></span><br><span class="line"><span class="function"> */</span></span><br></pre></td></tr></table></figure><p>这段代码的第十行的告诉我们，如果需要 useRef 的直接可变，就需要在泛型参数中包含’| null’，所以这就是当初始值为 null 的第二种定义形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameInput = React.useRef&lt;HTMLInputElement | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>这种形式下，nameInput.current 就是可写的。不过两种类型在使用时都需要做类型检查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameInput.current?.innerText = <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>那么问题来了，为什么第一种写法在没有操作 current 时没有报错呢？因为 useRef 在类型定义式具有多个重载声明，第一种方式就是执行的以下函数重载：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T | <span class="literal">null</span></span>): <span class="title">RefObject</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">// <span class="title">convenience</span> <span class="title">overload</span> <span class="title">for</span> <span class="title">potentially</span> <span class="title">undefined</span> <span class="title">initialValue</span> / <span class="title">call</span> <span class="title">with</span> 0 <span class="title">arguments</span></span></span><br><span class="line"><span class="function">// <span class="title">has</span> <span class="title">a</span> <span class="title">default</span> <span class="title">to</span> <span class="title">stop</span> <span class="title">it</span> <span class="title">from</span> <span class="title">defaulting</span> <span class="title">to</span> </span>&#123;&#125; instead</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument</span></span><br><span class="line"><span class="comment"> * (`initialValue`). The returned object will persist for the full lifetime of the component.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable</span></span><br><span class="line"><span class="comment"> * value around similar to how you’d use instance fields in classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version </span>16.8.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see </span>https://reactjs.org/docs/hooks-reference.html#useref</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从上 useRef 的声明中可以看到，function useRef 的返回值类型化是 MutableRefObject，这里面的 T 就是参数的类型 T，所以最终 nameInput 的类型就是 React.MutableRefObject。</p><p>注意，上面用到了 HTMLInputElement 类型，这是一个标签类型，这个操作就是用来访问 DOM 元素的。</p><h3 id="4-useCallback"><a href="#4-useCallback" class="headerlink" title="4. useCallback"></a>4. useCallback</h3><p>先来看看类型声明文件中对 useCallback 的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>&lt;<span class="title">T</span> <span class="title">extends</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; <span class="title">any</span>&gt;(<span class="params">callback: T, deps: DependencyList</span>): <span class="title">T</span></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * `<span class="title">useMemo</span>` <span class="title">will</span> <span class="title">only</span> <span class="title">recompute</span> <span class="title">the</span> <span class="title">memoized</span> <span class="title">value</span> <span class="title">when</span> <span class="title">one</span> <span class="title">of</span> <span class="title">the</span> `<span class="title">deps</span>` <span class="title">has</span> <span class="title">changed</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * <span class="title">Usage</span> <span class="title">note</span>: <span class="title">if</span> <span class="title">calling</span> `<span class="title">useMemo</span>` <span class="title">with</span> <span class="title">a</span> <span class="title">referentially</span> <span class="title">stable</span> <span class="function"><span class="keyword">function</span>, <span class="title">also</span> <span class="title">give</span> <span class="title">it</span> <span class="title">as</span> <span class="title">the</span> <span class="title">input</span> <span class="title">in</span></span></span></span><br><span class="line"><span class="function"><span class="function"> * <span class="title">the</span> <span class="title">second</span> <span class="title">argument</span>.</span></span></span><br><span class="line"><span class="function"><span class="function"> *</span></span></span><br><span class="line"><span class="function"><span class="function"> * ```<span class="title">ts</span></span></span></span><br><span class="line"><span class="function"><span class="function"> * <span class="function"><span class="keyword">function</span> <span class="title">expensive</span> (<span class="params"></span>) </span>&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="function"> *</span></span></span><br><span class="line"><span class="function"><span class="function"> * <span class="function"><span class="keyword">function</span> <span class="title">Component</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function"> *   <span class="title">const</span> <span class="title">expensiveResult</span> = <span class="title">useMemo</span>(<span class="params">expensive, [expensive]</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"> *   <span class="title">return</span> ...</span></span></span><br><span class="line"><span class="function"><span class="function"> * &#125;</span></span></span><br><span class="line"><span class="function"><span class="function"> * ```</span></span></span><br><span class="line"><span class="function"><span class="function"> *</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">usememo</span></span></span></span><br><span class="line"><span class="function"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure><p>useCallback 接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    add(a, b)</span><br><span class="line">  &#125;,</span><br><span class="line">  [b]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们没有给回调函数中的参数 a 定义类型，所以下面的调用方式都不会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memoizedCallback(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">memoizedCallback(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>尽管 add 方法的两个参数都是 number 类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    add(a, b)</span><br><span class="line">  &#125;,</span><br><span class="line">  [b]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这时候如果再给回调函数传入字符串就会报错了：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6f409391494f51bfb5c3e905f9fc1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"> 所有，需要注意，在使用 useCallback 时需要给回调函数的参数指定类型。</p><h3 id="5-useMemo"><a href="#5-useMemo" class="headerlink" title="5. useMemo"></a>5. useMemo</h3><p>先来看看类型声明文件中对 useMemo 的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params">factory: () =&gt; T, deps: DependencyList | <span class="literal">undefined</span></span>): <span class="title">T</span></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * `<span class="title">useDebugValue</span>` <span class="title">can</span> <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">display</span> <span class="title">a</span> <span class="title">label</span> <span class="title">for</span> <span class="title">custom</span> <span class="title">hooks</span> <span class="title">in</span> <span class="title">React</span> <span class="title">DevTools</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * <span class="title">NOTE</span>: <span class="title">We</span> <span class="title">don</span>’<span class="title">t</span> <span class="title">recommend</span> <span class="title">adding</span> <span class="title">debug</span> <span class="title">values</span> <span class="title">to</span> <span class="title">every</span> <span class="title">custom</span> <span class="title">hook</span>.</span></span><br><span class="line"><span class="function"> * <span class="title">It</span>’<span class="title">s</span> <span class="title">most</span> <span class="title">valuable</span> <span class="title">for</span> <span class="title">custom</span> <span class="title">hooks</span> <span class="title">that</span> <span class="title">are</span> <span class="title">part</span> <span class="title">of</span> <span class="title">shared</span> <span class="title">libraries</span>.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span><br><span class="line"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">usedebugvalue</span></span></span><br><span class="line"><span class="function"> */</span></span><br></pre></td></tr></table></figure><p>useMemo 和 useCallback 是非常类似的，但是它返回的是一个值，而不是函数。所以在定义 useMemo 时需要定义返回值的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  a += <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculatedValue = useMemo&lt;<span class="built_in">number</span>&gt;(<span class="function">() =&gt;</span> a ** <span class="number">2</span>, [a])</span><br></pre></td></tr></table></figure><p>如果返回值不一致，就会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculatedValue = useMemo&lt;<span class="built_in">number</span>&gt;(<span class="function">() =&gt;</span> a + <span class="string">&#x27;hello&#x27;</span>, [a])</span><br><span class="line"><span class="comment">// 类型“() =&gt; string”的参数不能赋给类型“() =&gt; number”的参数</span></span><br></pre></td></tr></table></figure><h3 id="6-useContext"><a href="#6-useContext" class="headerlink" title="6. useContext"></a>6. useContext</h3><p>useContext 需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ColorContext = React.createContext(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color &#125; = useContext(ColorContext)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 useContext 时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置 context 的类型。当前，我们也可以使用泛型来设置 context 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IColor &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ColorContext = React.createContext&lt;IColor&gt;(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>下面是 useContext 在类型声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useContext</span>&lt;<span class="title">T</span>&gt;(<span class="params">context: Context&lt;T&gt; <span class="comment">/*, (not public API) observedBits?: number|boolean */</span></span>): <span class="title">T</span></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * <span class="title">Returns</span> <span class="title">a</span> <span class="title">stateful</span> <span class="title">value</span>, <span class="title">and</span> <span class="title">a</span> <span class="function"><span class="keyword">function</span> <span class="title">to</span> <span class="title">update</span> <span class="title">it</span>.</span></span></span><br><span class="line"><span class="function"><span class="function"> *</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">version</span> 16.8.0</span></span></span><br><span class="line"><span class="function"><span class="function"> * @<span class="title">see</span> <span class="title">https</span>://<span class="title">reactjs</span>.<span class="title">org</span>/<span class="title">docs</span>/<span class="title">hooks</span>-<span class="title">reference</span>.<span class="title">html</span>#<span class="title">usestate</span></span></span></span><br><span class="line"><span class="function"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure><h3 id="7-useReducer"><a href="#7-useReducer" class="headerlink" title="7. useReducer"></a>7. useReducer</h3><p>有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用 useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的 state。其语法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init)</span><br></pre></td></tr></table></figure><p>来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的状态是无法推断出来的，可以给 reducer 函数添加类型，通过给 reducer 函数定义 state 和 action 来推断 useReducer 的类型，下面来修改上面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ActionType = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> | <span class="string">&#x27;decrement&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State = &#123; <span class="attr">count</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState: State = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state: State, action: ActionType</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在 Counter 函数中就可以推断出类型。当我们视图使用一个不存在的类型时，就会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// Error! type &#x27;&quot;reset&quot;&#x27; is not assignable to type &#x27;&quot;increment&quot; | &quot;decrement&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>除此之外，还可以使用泛型的形式来实现 reducer 函数的类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ActionType = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> | <span class="string">&#x27;decrement&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State = &#123; <span class="attr">count</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer: React.Reducer&lt;State, ActionType&gt; = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 dispatch 方法也是有类型的：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10417c4c14704f3eabde9e658535fbc7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>可以看到，dispatch 的类型是：React.Dispatch，上面示例的完整代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ActionType = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> | <span class="string">&#x27;decrement&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State = &#123; <span class="attr">count</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reducer: React.Reducer&lt;State, ActionType&gt; = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> initialState: State = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><h2 id="四、事件处理"><a href="#四、事件处理" class="headerlink" title="四、事件处理"></a>四、事件处理</h2><h3 id="1-Event-事件类型"><a href="#1-Event-事件类型" class="headerlink" title="1. Event 事件类型"></a>1. Event 事件类型</h3><p>在开发中我们会经常在事件处理函数中使用 event 事件对象，比如在 input 框输入时实时获取输入的值；使用鼠标事件时，通过 clientX、clientY 获取当前指针的坐标等等。</p><p>我们知道，Event 是一个对象，并且有很多属性，这时很多人就会把 event 类型定义为 any，这样的话 TypeScript 就失去了它的意义，并不会对 event 事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleEvent = <span class="function">(<span class="params">e: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.clientX, e.clientY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Event 事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个 interface 中，所以 React 在声明文件中给我们提供了 Event 事件对象的类型声明。</p><p>常见的 Event 事件对象如下：</p><ul><li><strong>剪切板事件对象</strong>：ClipboardEvent&lt;T = Element&gt;</li><li><strong>拖拽事件对象</strong>：DragEvent&lt;T = Element&gt;</li><li><strong>焦点事件对象</strong>：FocusEvent&lt;T = Element&gt;</li><li><strong>表单事件对象</strong>：FormEvent&lt;T = Element&gt;</li><li><strong>Change 事件对象</strong>：ChangeEvent&lt;T = Element&gt;</li><li><strong>键盘事件对象</strong>：KeyboardEvent&lt;T = Element&gt;</li><li><strong>鼠标事件对象</strong>：MouseEvent&lt;T = Element, E = NativeMouseEvent&gt;</li><li><strong>触摸事件对象</strong>：TouchEvent&lt;T = Element&gt;</li><li><strong>滚轮事件对象</strong>：WheelEvent&lt;T = Element&gt;</li><li><strong>动画事件对象</strong>：AnimationEvent&lt;T = Element&gt;</li><li><strong>过渡事件对象</strong>：TransitionEvent&lt;T = Element&gt;</li></ul><p>可以看到，这些 Event 事件对象的泛型中都会接收一个 Element 元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。</p><p>来看一个简单的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    setText(e.currentTarget.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就给 onChange 方法的事件对象定义为了 FormEvent 类型，并且作用的对象时一个 HTMLInputElement 类型的标签（input 标签）</p><p>可以来看下 MouseEvent 事件对象和 ChangeEvent 事件对象的类型声明，其他事件对象的声明形似也类似：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MouseEvent&lt;T = Element, E = NativeMouseEvent&gt; <span class="keyword">extends</span> UIEvent&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="attr">altKey</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">button</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">buttons</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">clientX</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">clientY</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">ctrlKey</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * See [DOM Level 3 Events spec](https://www.w3.org/TR/uievents-key/#keys-modifier). for a list of valid (case-sensitive) arguments to this method.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getModifierState(key: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">metaKey</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">movementX</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">movementY</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">pageX</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">pageY</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">relatedTarget</span>: EventTarget | <span class="literal">null</span></span><br><span class="line">  <span class="attr">screenX</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">screenY</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">shiftKey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ChangeEvent&lt;T = Element&gt; <span class="keyword">extends</span> SyntheticEvent&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">target</span>: EventTarget &amp; T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在很多事件对象的声明文件中都可以看到 EventTarget 的身影。这是因为，DOM 的事件操作（监听和触发），都定义在 EventTarget 接口上。EventTarget 的类型声明如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> EventTarget &#123;</span><br><span class="line">  addEventListener(</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">listener</span>: EventListenerOrEventListenerObject | <span class="literal">null</span>,</span><br><span class="line">    options?: <span class="built_in">boolean</span> | AddEventListenerOptions</span><br><span class="line">  ): <span class="built_in">void</span></span><br><span class="line">  dispatchEvent(evt: Event): <span class="built_in">boolean</span></span><br><span class="line">  removeEventListener(</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>,</span><br><span class="line">    listener?: EventListenerOrEventListenerObject | <span class="literal">null</span>,</span><br><span class="line">    options?: EventListenerOptions | <span class="built_in">boolean</span></span><br><span class="line">  ): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 change 事件中，会使用的 e.target 来获取当前的值，它的的类型就是 EventTarget。来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> onSourceChange(e)&#125; placeholder=&quot;最多30个字&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onSourceChange = <span class="function">(<span class="params">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.target.value.length &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    message.error(<span class="string">&#x27;请长度不能超过30个字，请重新输入&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  setSourceInput(e.target.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个 input 输入框，当触发 onChange 事件时，会调用 onSourceChange 方法，该方法的参数 e 的类型就是：React.ChangeEvent，而 e.target 的类型就是 EventTarget：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be7d97e6011a4e61bc1d18c141a4c4bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>在来看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">questionList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    	<span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  	<span class="attr">role</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  	<span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> handleChangeCurrent(item, e)&#125;</span></span><br><span class="line"><span class="xml">    &gt;</span></span><br><span class="line"><span class="xml">    // 组件内容...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleChangeCurrent = <span class="function">(<span class="params">item: IData, e: React.MouseEvent&lt;HTMLDivElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    setCurrent(item);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发 handleChangeCurren 方法，该方法有两个参数，第二个参数是 event 对象，在方法中执行了 e.stopPropagation();是为了阻止冒泡事件，这里的 stopPropagation()实际上并不是鼠标事件 MouseEvent 的属性，它是合成事件上的属性，来看看声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MouseEvent&lt;T = Element, E = NativeMouseEvent&gt; <span class="keyword">extends</span> UIEvent&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UIEvent&lt;T = Element, E = NativeUIEvent&gt; <span class="keyword">extends</span> SyntheticEvent&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SyntheticEvent&lt;T = Element, E = Event&gt;</span><br><span class="line">  <span class="keyword">extends</span> BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BaseSyntheticEvent&lt;E = object, C = any, T = any&gt; &#123;</span><br><span class="line">  <span class="attr">nativeEvent</span>: E</span><br><span class="line">  <span class="attr">currentTarget</span>: C</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">cancelable</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">defaultPrevented</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">eventPhase</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">isTrusted</span>: <span class="built_in">boolean</span></span><br><span class="line">  preventDefault(): <span class="built_in">void</span></span><br><span class="line">  isDefaultPrevented(): <span class="built_in">boolean</span></span><br><span class="line">  stopPropagation(): <span class="built_in">void</span></span><br><span class="line">  isPropagationStopped(): <span class="built_in">boolean</span></span><br><span class="line">  persist(): <span class="built_in">void</span></span><br><span class="line">  <span class="attr">timeStamp</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的 stopPropagation()是一层层的继承来的，最终来自于 BaseSyntheticEvent 合成事件类型。原生的事件集合 SyntheticEvent 就是继承自合成时间类型。SyntheticEvent&lt;T = Element, E = Event&gt;泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  onChange=&#123;<span class="function">(<span class="params">e: SyntheticEvent&lt;Element, Event&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3 id="2-事件处理函数类型"><a href="#2-事件处理函数类型" class="headerlink" title="2. 事件处理函数类型"></a>2. 事件处理函数类型</h3><p>说完事件对象类型，再来看看事件处理函数的类型。React 也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  bivarianceHack(event: E): <span class="built_in">void</span></span><br><span class="line">&#125;[<span class="string">&#x27;bivarianceHack&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 剪切板事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 复合事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 拖拽事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 焦点事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 表单事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// Change事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 键盘事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 鼠标事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 触屏事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 指针事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 界面事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 滚轮事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 动画事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 过渡事件处理函数</span></span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>这里面的 T 的类型也都是 Element，指的是触发该事件的 HTML 标签元素的类型，下面第五部分会介绍。</p><p>EventHandler 会接收一个 E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个 Event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。</p><p>还看上面的那个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(e.currentTarget.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给 onChange 方法定义了方法的类型，它是一个 ChangeEventHandler 的类型，并且作用的对象时一个 HTMLImnputElement 类型的标签（input 标签）。</p><h2 id="五、HTML-标签类型"><a href="#五、HTML-标签类型" class="headerlink" title="五、HTML 标签类型"></a>五、HTML 标签类型</h2><h3 id="1-常见标签类型"><a href="#1-常见标签类型" class="headerlink" title="1. 常见标签类型"></a>1. 常见标签类型</h3><p>在项目的依赖文件中可以找到 HTML 标签相关的类型声明文件：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1dbae29dbaa45fc96da354807199b6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>所有的 HTML 标签的类型都被定义在 intrinsicElements 接口中，常见的标签及其类型如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a: HTMLAnchorElement</span><br><span class="line"><span class="attr">body</span>: HTMLBodyElement</span><br><span class="line"><span class="attr">br</span>: HTMLBRElement</span><br><span class="line"><span class="attr">button</span>: HTMLButtonElement</span><br><span class="line"><span class="attr">div</span>: HTMLDivElement</span><br><span class="line"><span class="attr">h1</span>: HTMLHeadingElement</span><br><span class="line"><span class="attr">h2</span>: HTMLHeadingElement</span><br><span class="line"><span class="attr">h3</span>: HTMLHeadingElement</span><br><span class="line"><span class="attr">html</span>: HTMLHtmlElement</span><br><span class="line"><span class="attr">img</span>: HTMLImageElement</span><br><span class="line"><span class="attr">input</span>: HTMLInputElement</span><br><span class="line"><span class="attr">ul</span>: HTMLUListElement</span><br><span class="line"><span class="attr">li</span>: HTMLLIElement</span><br><span class="line"><span class="attr">link</span>: HTMLLinkElement</span><br><span class="line"><span class="attr">p</span>: HTMLParagraphElement</span><br><span class="line"><span class="attr">span</span>: HTMLSpanElement</span><br><span class="line"><span class="attr">style</span>: HTMLStyleElement</span><br><span class="line"><span class="attr">table</span>: HTMLTableElement</span><br><span class="line"><span class="attr">tbody</span>: HTMLTableSectionElement</span><br><span class="line"><span class="attr">video</span>: HTMLVideoElement</span><br><span class="line"><span class="attr">audio</span>: HTMLAudioElement</span><br><span class="line"><span class="attr">meta</span>: HTMLMetaElement</span><br><span class="line"><span class="attr">form</span>: HTMLFormElement</span><br></pre></td></tr></table></figure><p>那什么时候会使用到标签类型呢，上面第四部分的 Event 事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个 ELement 类型的泛型参数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自 HTMLElement 类型，如果使用时对类型类型要求不高，可以直接写 HTMLELement。比如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">  <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span></span><br><span class="line">  onClick=&#123;<span class="function">(<span class="params">e: React.MouseEvent&lt;HTMLElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    handleOperate()</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;cancelChangeIcon&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line">  取消修改</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure><p>其实，在直接操作 DOM 时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作 DOM。比如我在工作中，项目中的某一部分组件是通过 npm 来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生 JavaScript 获取到 DOM 元素，来进行样式的修改，这时候就会用到标签类型。</p><p>来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.paper&#x27;</span>).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> firstPageHasAddEle = (item.firstChild <span class="keyword">as</span> HTMLDivElement).classList.contains(<span class="string">&#x27;add-ele&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (firstPageHasAddEle) &#123;</span><br><span class="line">    item.removeChild(item.firstChild <span class="keyword">as</span> ChildNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是我最近写的一段代码（略微删改），在第一页有个 add-ele 元素的时候就删除它。这里我们将 item.firstChild 断言成了 HTMLDivElement 类型，如果不断言，item.firstChild 的类型就是 ChildNode，而 ChildNode 类型中是不存在 classList 属性的，所以就就会报错，当我们把他断言成 HTMLDivElement 类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。</p><p>后面在 removeChild 时又使用了 as 断言，为什么呢？item.firstChild 不是已经自动识别为 ChildNode 类型了吗？因为 TS 会认为，我们可能不能获取到类名为 paper 的元素，所以 item.firstChild 的类型就被推断为 ChildNode | null，我们有时候比 TS 更懂我们定义的元素，知道页面一定存在 paper 元素，所以可以直接将 item.firstChild 断言成 ChildNode 类型。</p><h3 id="2-标签属性类型"><a href="#2-标签属性类型" class="headerlink" title="2. 标签属性类型"></a>2. 标签属性类型</h3><p>众所周知，每个 HTML 标签都有自己的属性，比如 Input 框就有 value、width、placeholder、max-length 等属性，下面是 Input 框的属性类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> InputHTMLAttributes&lt;T&gt; <span class="keyword">extends</span> HTMLAttributes&lt;T&gt; &#123;</span><br><span class="line">  accept?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  alt?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  autoComplete?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  autoFocus?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  capture?: <span class="built_in">boolean</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  checked?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  crossOrigin?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  disabled?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  enterKeyHint?: <span class="string">&#x27;enter&#x27;</span> | <span class="string">&#x27;done&#x27;</span> | <span class="string">&#x27;go&#x27;</span> | <span class="string">&#x27;next&#x27;</span> | <span class="string">&#x27;previous&#x27;</span> | <span class="string">&#x27;search&#x27;</span> | <span class="string">&#x27;send&#x27;</span> | <span class="literal">undefined</span></span><br><span class="line">  form?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  formAction?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  formEncType?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  formMethod?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  formNoValidate?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  formTarget?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  height?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  list?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  max?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  maxLength?: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">  min?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  minLength?: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">  multiple?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  name?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  pattern?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  placeholder?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  readOnly?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  required?: <span class="built_in">boolean</span> | <span class="literal">undefined</span></span><br><span class="line">  size?: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">  src?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  step?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">type</span>?: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  value?: <span class="built_in">string</span> | ReadonlyArray&lt;<span class="built_in">string</span>&gt; | <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">  width?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  onChange?: ChangeEventHandler&lt;T&gt; | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要直接操作 DOM，就可能会用到元素属性类型，常见的元素属性类型如下：</p><ul><li>HTML 属性类型：HTMLAttributes</li><li>按钮属性类型：ButtonHTMLAttributes</li><li>表单属性类型：FormHTMLAttributes</li><li>图片属性类型：ImgHTMLAttributes</li><li>输入框属性类型：InputHTMLAttributes</li><li>链接属性类型：LinkHTMLAttributes</li><li>meta 属性类型：MetaHTMLAttributes</li><li>选择框属性类型：SelectHTMLAttributes</li><li>表格属性类型：TableHTMLAttributes</li><li>输入区属性类型：TextareaHTMLAttributes</li><li>视频属性类型：VideoHTMLAttributes</li><li>SVG 属性类型：SVGAttributes</li><li>WebView 属性类型：WebViewHTMLAttributes</li></ul><p>一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ButtonSize &#123;</span><br><span class="line">  Large = <span class="string">&#x27;lg&#x27;</span>,</span><br><span class="line">  Small = <span class="string">&#x27;sm&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ButtonType &#123;</span><br><span class="line">  Primary = <span class="string">&#x27;primary&#x27;</span>,</span><br><span class="line">  Default = <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">  Danger = <span class="string">&#x27;danger&#x27;</span>,</span><br><span class="line">  Link = <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BaseButtonProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span></span><br><span class="line">  disabled?: <span class="built_in">boolean</span></span><br><span class="line">  size?: ButtonSize</span><br><span class="line">  btnType?: ButtonType</span><br><span class="line">  <span class="attr">children</span>: React.ReactNode</span><br><span class="line">  href?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NativeButtonProps = BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; <span class="comment">// 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 button 的属性</span></span><br><span class="line"><span class="keyword">type</span> AnchorButtonProps = BaseButtonProps &amp; React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; <span class="comment">// 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 a标签 的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt; <span class="comment">//使用 Partial&lt;&gt; 使两种属性可选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button: React.FC&lt;ButtonProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; disabled, className, size, btnType, children, href, ...restProps &#125; = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> classes = classNames(<span class="string">&#x27;btn&#x27;</span>, className, &#123;</span><br><span class="line">    [<span class="string">`btn-<span class="subst">$&#123;btnType&#125;</span>`</span>]: btnType,</span><br><span class="line">    [<span class="string">`btn-<span class="subst">$&#123;size&#125;</span>`</span>]: size,</span><br><span class="line">    <span class="attr">disabled</span>: btnType === ButtonType.Link &amp;&amp; disabled, <span class="comment">// 只有 a 标签才有 disabled 类名，button没有</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (btnType === ButtonType.Link &amp;&amp; href) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">className</span>=<span class="string">&#123;classes&#125;</span> <span class="attr">href</span>=<span class="string">&#123;href&#125;</span> &#123;<span class="attr">...restProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;children&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">className</span>=<span class="string">&#123;classes&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">disabled</span>=<span class="string">&#123;disabled&#125;</span> // <span class="attr">button</span>元素默认有<span class="attr">disabled</span>属性，所以即便没给他设置样式也会和普通<span class="attr">button</span>有一定区别</span></span></span><br><span class="line"><span class="tag"><span class="xml">        &#123;<span class="attr">...restProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      &gt;</span></span></span><br><span class="line"><span class="xml">        &#123;children&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button.defaultProps = &#123;</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">btnType</span>: ButtonType.Default,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button</span><br></pre></td></tr></table></figure><p>这段代码就是用来封装一个 buttom 按钮，在 button 的基础上添加了一些自定义属性，比如上面将 button 的类型使用交叉类型（&amp;）获得自定义属性和原生 button 属性 ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NativeButtonProps = BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt;</span><br></pre></td></tr></table></figure><p>可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~</p><h2 id="六、工具泛型"><a href="#六、工具泛型" class="headerlink" title="六、工具泛型"></a>六、工具泛型</h2><p>在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。</p><h3 id="1-Partial"><a href="#1-Partial" class="headerlink" title="1. Partial"></a>1. Partial</h3><p>Partial 作用是<strong>将传入的属性变为可选项</strong>。适用于对类型结构不明确的情况。它使用了两个关键字：keyof 和 in，先来看看他们都是什么含义。keyof 可以用来取得接口的所有 key 值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = keyof IPerson</span><br><span class="line"><span class="comment">// T 类型为： &quot;name&quot; | &quot;age&quot; | &quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>in 关键字可以遍历枚举类型,：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Obj类型为： &#123; name: any, age: any, number: any &#125;</span></span><br></pre></td></tr></table></figure><p>keyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是 Partial 工具泛型的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> * 将T中的所有属性设置为可选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。</p><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Partial&lt;IPerson&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-Required"><a href="#2-Required" class="headerlink" title="2. Required"></a>2. Required</h3><p>Required 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T required</span></span><br><span class="line"><span class="comment"> * 将T中的所有属性设置为必选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。适用形式和上面的 Partial 差不多：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Required&lt;IPerson&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">  age: <span class="number">18</span>;</span><br><span class="line">  height: <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-Readonly"><a href="#3-Readonly" class="headerlink" title="3. Readonly"></a>3. Readonly</h3><p>将 T 类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly 的声明形式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T readonly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Readonly&lt;IPerson&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span> <span class="comment">//  Error: cannot reassign a readonly property</span></span><br></pre></td></tr></table></figure><p>可以看到，通过 Readonly 将 IPerson 的属性转化成了只读，不能再进行赋值操作。</p><h3 id="4-Pick-lt-T-K-extends-keyof-T-gt"><a href="#4-Pick-lt-T-K-extends-keyof-T-gt" class="headerlink" title="4. Pick&lt;T, K extends keyof T&gt;"></a>4. Pick&lt;T, K extends keyof T&gt;</h3><p>从 T 类型中挑选部分属性 K 来构造新的类型。它的声明形式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Pick&lt;IPerson, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Record-lt-K-extends-keyof-any-T-gt"><a href="#5-Record-lt-K-extends-keyof-any-T-gt" class="headerlink" title="5. Record&lt;K extends keyof any, T&gt;"></a>5. Record&lt;K extends keyof any, T&gt;</h3><p>Record 用来构造一个类型，其属性名的类型为 K，属性值的类型为 T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPageinfo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPage = <span class="string">&#x27;home&#x27;</span> | <span class="string">&#x27;about&#x27;</span> | <span class="string">&#x27;contact&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page: Record&lt;IPage, IPageinfo&gt; = &#123;</span><br><span class="line">  <span class="attr">about</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;about&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">contact</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;contact&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">home</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;home&#x27;</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Exclude-lt-T-U-gt"><a href="#6-Exclude-lt-T-U-gt" class="headerlink" title="6. Exclude&lt;T, U&gt;"></a>6. Exclude&lt;T, U&gt;</h3><p>Exclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Exclude&lt;IPerson, <span class="string">&quot;age&quot;</span> | <span class="string">&quot;sex&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">  height: <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-Omit-lt-T-K-extends-keyof-any-gt"><a href="#7-Omit-lt-T-K-extends-keyof-any-gt" class="headerlink" title="7. Omit&lt;T, K extends keyof any&gt;"></a>7. Omit&lt;T, K extends keyof any&gt;</h3><p>上面的 Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit 就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Omit&lt;IPerson, <span class="string">&quot;age&quot;</span> | <span class="string">&quot;height&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-ReturnType"><a href="#8-ReturnType" class="headerlink" title="8. ReturnType"></a>8. ReturnType</h3><p>ReturnType 会返回函数返回值的类型，其声明形式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span></span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="keyword">type</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">type</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooType = ReturnType&lt;<span class="keyword">typeof</span> foo&gt;</span><br></pre></td></tr></table></figure><p>这里使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) =&gt; boolean。</p><h2 id="七、Axios-封装"><a href="#七、Axios-封装" class="headerlink" title="七、Axios 封装"></a>七、Axios 封装</h2><p>在 React 项目中，我们经常使用 Axios 库进行数据请求，Axios 是基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：</p><ul><li>从浏览器中创建 XMLHttpRequests；</li><li>从 node.js 创建 HTTP 请求；</li><li>支持 Promise API；</li><li>拦截请求和响应；</li><li>转换请求数据和响应数据；</li><li>取消请求；</li><li>自动转换 JSON 数据；</li><li>客户端支持防御 XSRF。</li></ul><p>Axios 的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对 Axios 进行封装，下面就使用 TypeScript 对 Axios 进行简单封装，使其同时能够有很好的类型支持。Axios 是自带声明文件的，所以我们无需额外的操作。</p><p>下面来看基本的封装：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span> <span class="comment">// 引入axios和定义在node_modules/axios/index.ts文件里的类型声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口请求类，用于创建axios请求实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接收接口请求的基本路径</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> baseUrl: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用接口时调用实例的这个方法，返回AxiosPromise</span></span><br><span class="line">  <span class="keyword">public</span> request(options: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">    <span class="comment">// 创建axios实例，它是函数，同时这个函数包含多个属性</span></span><br><span class="line">    <span class="keyword">const</span> instance: AxiosInstance = axios.create()</span><br><span class="line">    <span class="comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span></span><br><span class="line">    options = <span class="built_in">this</span>.mergeConfig(options)</span><br><span class="line">    <span class="comment">// 调用interceptors方法使拦截器生效</span></span><br><span class="line">    <span class="built_in">this</span>.interceptors(instance, options.url)</span><br><span class="line">    <span class="comment">// 返回AxiosPromise</span></span><br><span class="line">    <span class="keyword">return</span> instance(options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于添加全局请求和响应拦截</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">interceptors</span>(<span class="params">instance: AxiosInstance, url?: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 请求和响应拦截</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于合并基础路径配置和接口单独配置</span></span><br><span class="line">  <span class="keyword">private</span> mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123; <span class="attr">baseURL</span>: <span class="built_in">this</span>.baseUrl &#125;, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure><p>通常 baseUrl 在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">api</span>: &#123;</span><br><span class="line">    <span class="attr">devApiBaseUrl</span>: <span class="string">&#x27;/test/api/xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">proApiBaseUrl</span>: <span class="string">&#x27;/api/xxx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的文件中引入这个配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="attr">api</span>: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> apiBaseUrl = env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? proApiBaseUrl : devApiBaseUrl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后就可以将 apiBaseUrl 作为默认值传入 HttpRequest 的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> baseUrl: <span class="built_in">string</span> = apiBaseUrl</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来可以完善一下拦截器类，在类中 interceptors 方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="title">interceptors</span>(<span class="params">instance: AxiosInstance, url?: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 请求拦截</span></span><br><span class="line">    instance.interceptors.request.use(<span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 接口请求的所有配置，可以在axios.defaults修改配置</span></span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 响应拦截</span></span><br><span class="line">    instance.interceptors.response.use(<span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">      <span class="keyword">const</span> &#123; code, msg &#125; = data</span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(msg)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResponseData &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span></span><br><span class="line">  data?: <span class="built_in">any</span></span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看使用 TypeScript 封装的 Axios 该如何使用。可以先定义一个请求实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HttpRequest <span class="keyword">from</span> <span class="string">&#x27;@/utils/axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@/utils/axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest()</span><br></pre></td></tr></table></figure><p>这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; ResponseData &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; AxiosPromise &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ILogin &#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginReq = (data: ILogin): AxiosPromise&lt;ResponseData&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user/login&#x27;</span>,</span><br><span class="line">    data,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里封装登录请求方法 loginReq，他的参数必须是我们定义的 ILogin 接口的类型。这个方法返回一个类型为<code>AxiosPromise</code>的 Promise，AxiosPromise 是 axios 声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中 data 字段的类型。</p><p>接下来可以调用一下这个登录的接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loginReq &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home: FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> login = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    loginReq(params).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res.data.code)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，当我们调用 loginReq 接口时，就会提示我们，参数的类型是 ILogin，需要传入几个参数。这样编写代码的体验就会好很多。</p><h2 id="八-其他"><a href="#八-其他" class="headerlink" title="八. 其他"></a>八. 其他</h2><h3 id="1-import-React"><a href="#1-import-React" class="headerlink" title="1. import React"></a>1. import React</h3><p>在 React 项目中使用 TypeScript 时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>就需要在 tsconfig.json 配置文件中进行如下配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 允许默认从没有默认导出的模块导入。</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-Types-or-Interfaces？"><a href="#2-Types-or-Interfaces？" class="headerlink" title="2. Types or Interfaces？"></a>2. Types or Interfaces？</h3><p>我们可以使用 types 或者 Interfaces 来定义类型吗，那么该如何选择他俩呢？建议如下：</p><ul><li>在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；</li><li>在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。</li></ul><p>interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以继续在原属性基础上，添加新属性：color</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type类型不支持属性扩展</span></span><br><span class="line"><span class="comment">// Error: Duplicate identifier &#x27;Animal&#x27;</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type 对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而 interface 更适合声明字典类行，然后定义或者扩展它。</p><h3 id="3-懒加载类型"><a href="#3-懒加载类型" class="headerlink" title="3. 懒加载类型"></a>3. 懒加载类型</h3><p>如果我们想在 React router 中使用懒加载，React 也为我们提供了懒加载方法的类型，来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RouteType &#123;</span><br><span class="line">  <span class="attr">pathname</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">component</span>: LazyExoticComponent&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">  exact: <span class="built_in">boolean</span></span><br><span class="line">  title?: <span class="built_in">string</span></span><br><span class="line">  icon?: <span class="built_in">string</span></span><br><span class="line">  children?: RouteType[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: RouteType[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Login/Login&#x27;</span>)),</span><br><span class="line">    <span class="attr">exact</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/404/404&#x27;</span>)),</span><br><span class="line">    <span class="attr">exact</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">exact</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">component</span>: lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Admin/Admin&#x27;</span>)),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>下面是懒加载类型和 lazy 方法在声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LazyExoticComponent&lt;T <span class="keyword">extends</span> ComponentType&lt;<span class="built_in">any</span>&gt;&gt; = ExoticComponent&lt;</span><br><span class="line">  ComponentPropsWithRef&lt;T&gt;</span><br><span class="line">&gt; &amp; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> _result: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ComponentType</span>&lt;<span class="title">any</span>&gt;&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  factory: () =&gt; <span class="built_in">Promise</span>&lt;&#123; <span class="keyword">default</span>: T &#125;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">LazyExoticComponent</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-类型断言"><a href="#4-类型断言" class="headerlink" title="4. 类型断言"></a>4. 类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。在 React 项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比 TS 更懂我们的代码，所以可以使用断言（使用 as 关键字）来定义一个值得类型。</p><p>来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getLength = (target: <span class="built_in">string</span> | <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (target.length) &#123;</span><br><span class="line">    <span class="comment">// error 类型&quot;string | number&quot;上不存在属性&quot;length&quot;</span></span><br><span class="line">    <span class="keyword">return</span> target.length <span class="comment">// error  类型&quot;number&quot;上不存在属性&quot;length&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数 target 和返回值的类型定义之后就会报错。这时就可以使用断言，将 target 的类型断言成 string 类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStrLength = (target: <span class="built_in">string</span> | <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((target <span class="keyword">as</span> <span class="built_in">string</span>).length) &#123;</span><br><span class="line">    <span class="keyword">return</span> (target <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。</p><p>再来看一个例子，在调用一个方法时传入参数： <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b4f7d1031e43c2a8194eae2aa15640~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"> 这里就提示我们这个参数可能是 undefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：<code>data?.subjectId as number</code></p><p>除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。</p><p>感悟：使用类型断言真的能解决项目中的很多报错~</p><h3 id="5-枚举类型"><a href="#5-枚举类型" class="headerlink" title="5. 枚举类型"></a>5. 枚举类型</h3><p>枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好新建一个文件专门来定义枚举值，便于引用。关于枚举类型的语法这里不在多介绍，可以参考之前的文章：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk4MzE4MjkxNDIwNzA4OTAw">《TS 入门篇 | 详解 TypeScript 枚举类型》<i class="fa fa-external-link-alt"></i></span>。</p><p>关于在 React 项目中如何优雅的使用 TypeScript 就先介绍这么多，后面有新的内容会再分享给大家。如果觉得不错就点个赞吧！</p><p>作者：CUGGZ<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDIxNjc0ODE4NjIxNjY5Mzg5">https://juejin.cn/post/7021674818621669389<i class="fa fa-external-link-alt"></i></span><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><div class="reward-container"><div>如果觉得文章有帮助，就请吃个雪糕吧~</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/wechatpay.png" alt="很帅很愁人~ 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>很帅很愁人~</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.wy1991.cn/20220325/207-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/" title="207-如何优雅地在 React 中使用TypeScript">https://blog.wy1991.cn/20220325/207-如何优雅地在-React-中使用TypeScript/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li><li class="post-copyright-license"><strong>联系方式： </strong>如文章有错误，请联系qq：598204996 谢谢~</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js/" rel="tag"># js</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20220325/206-react-hooks%E4%B8%AD-useState-useCallback-useMemo-useEffect%E5%A6%82%E4%BD%95%E5%88%86%E6%B8%85%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB,%E9%81%BF%E5%85%8D%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/" rel="prev" title="206-react-hooks中,useState,useCallback,useMemo,useEffect如何分清依赖关系,避免闭包问题"><i class="fa fa-chevron-left"></i> 206-react-hooks中,useState,useCallback,useMemo,useEffect如何分清依赖关系,避免闭包问题</a></div><div class="post-nav-item"><a href="/20220325/208-react-hooks-%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5useState/" rel="next" title="208-react-hooks-实现同步useState">208-react-hooks-实现同步useState <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">一、组件声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">1. 类组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">2. 函数组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81React-%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">二、React 内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JSX-Element"><span class="nav-number">2.1.</span> <span class="nav-text">1. JSX.Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-React-ReactElement"><span class="nav-number">2.2.</span> <span class="nav-text">2. React.ReactElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-React-ReactNode"><span class="nav-number">2.3.</span> <span class="nav-text">3. React.ReactNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-CSSProperties"><span class="nav-number">2.4.</span> <span class="nav-text">4. CSSProperties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81React-Hooks"><span class="nav-number">3.</span> <span class="nav-text">三、React Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-useState"><span class="nav-number">3.1.</span> <span class="nav-text">1. useState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-useEffect"><span class="nav-number">3.2.</span> <span class="nav-text">2. useEffect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-useRef"><span class="nav-number">3.3.</span> <span class="nav-text">3. useRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-useCallback"><span class="nav-number">3.4.</span> <span class="nav-text">4. useCallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-useMemo"><span class="nav-number">3.5.</span> <span class="nav-text">5. useMemo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-useContext"><span class="nav-number">3.6.</span> <span class="nav-text">6. useContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-useReducer"><span class="nav-number">3.7.</span> <span class="nav-text">7. useReducer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">四、事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Event-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">1. Event 事件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">2. 事件处理函数类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81HTML-%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">五、HTML 标签类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">1. 常见标签类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">2. 标签属性类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">六、工具泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Partial"><span class="nav-number">6.1.</span> <span class="nav-text">1. Partial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Required"><span class="nav-number">6.2.</span> <span class="nav-text">2. Required</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Readonly"><span class="nav-number">6.3.</span> <span class="nav-text">3. Readonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Pick-lt-T-K-extends-keyof-T-gt"><span class="nav-number">6.4.</span> <span class="nav-text">4. Pick&lt;T, K extends keyof T&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Record-lt-K-extends-keyof-any-T-gt"><span class="nav-number">6.5.</span> <span class="nav-text">5. Record&lt;K extends keyof any, T&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Exclude-lt-T-U-gt"><span class="nav-number">6.6.</span> <span class="nav-text">6. Exclude&lt;T, U&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Omit-lt-T-K-extends-keyof-any-gt"><span class="nav-number">6.7.</span> <span class="nav-text">7. Omit&lt;T, K extends keyof any&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ReturnType"><span class="nav-number">6.8.</span> <span class="nav-text">8. ReturnType</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81Axios-%E5%B0%81%E8%A3%85"><span class="nav-number">7.</span> <span class="nav-text">七、Axios 封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%85%B6%E4%BB%96"><span class="nav-number">8.</span> <span class="nav-text">八. 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-import-React"><span class="nav-number">8.1.</span> <span class="nav-text">1. import React</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Types-or-Interfaces%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">2. Types or Interfaces？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.3.</span> <span class="nav-text">3. 懒加载类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">8.4.</span> <span class="nav-text">4. 类型断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.5.</span> <span class="nav-text">5. 枚举类型</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="很帅很愁人~" src="/images/my.jpg"><p class="site-author-name" itemprop="name">很帅很愁人~</p><div class="site-description" itemprop="description">梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">210</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">46</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">116</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArryaBuffer/" rel="tag">ArryaBuffer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/" rel="tag">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recorder/" rel="tag">Recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/" rel="tag">TS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/" rel="tag">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/V8/" rel="tag">V8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueRouter/" rel="tag">VueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuex/" rel="tag">Vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebStorage/" rel="tag">WebStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86/" rel="tag">api集中管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apply/" rel="tag">apply</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios/" rel="tag">axios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bind/" rel="tag">bind</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call/" rel="tag">call</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cli/" rel="tag">cli</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cors/" rel="tag">cors</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/" rel="tag">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/drag/" rel="tag">drag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ejsexcel/" rel="tag">ejsexcel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/element/" rel="tag">element</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel%E5%AF%BC%E5%87%BA/" rel="tag">excel导出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filter/" rel="tag">filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/" rel="tag">flex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getters/" rel="tag">getters</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/host/" rel="tag">host</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/" rel="tag">html5</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jenkins/" rel="tag">jenkins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">82</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag">js基础语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%93%8D%E4%BD%9C%E7%AC%A6/" rel="tag">js操作符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/" rel="tag">lottie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/" rel="tag">media</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/messageChannel/" rel="tag">messageChannel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/miniVue/" rel="tag">miniVue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitt/" rel="tag">mitt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/" rel="tag">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/print/" rel="tag">print</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/" rel="tag">promise</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recorder/" rel="tag">recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ref/" rel="tag">ref</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rem/" rel="tag">rem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/require-context/" rel="tag">require.context</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reuqest/" rel="tag">reuqest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scss/" rel="tag">scss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sessionStorage/" rel="tag">sessionStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot/" rel="tag">slot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stackoverflow/" rel="tag">stackoverflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tailwind/" rel="tag">tailwind</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/" rel="tag">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/three/" rel="tag">three</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/utils/" rel="tag">utils</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vueRouter/" rel="tag">vueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex/" rel="tag">vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vw/" rel="tag">vw</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-worker/" rel="tag">web worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E6%89%93%E5%8D%B0/" rel="tag">web打印</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/worker/" rel="tag">worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlsx/" rel="tag">xlsx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yarn/" rel="tag">yarn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%BF%83/" rel="tag">初心</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB%E5%BA%93/" rel="tag">动画库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型与原型链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" rel="tag">发布订阅</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">多文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B1%8F/" rel="tag">大屏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" rel="tag">媒体查询</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/" rel="tag">字节序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/" rel="tag">封装请求</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/" rel="tag">居中对齐</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E5%BE%97/" rel="tag">心得</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/" rel="tag">性能监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%96%E6%8B%BD/" rel="tag">拖拽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E6%A7%BD/" rel="tag">插槽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B8%E5%86%8C/" rel="tag">相册</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="tag">移动端常见问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/" rel="tag">脚手架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" rel="tag">自动化部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" rel="tag">自适应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E8%AF%95/" rel="tag">调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/" rel="tag">辅助工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="tag">进程和线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E9%A1%B9%E7%9B%AE/" rel="tag">那些年做过的项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%83%A8%E7%BD%B2/" rel="tag">部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">1</span></li></ul></canvas></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">豫ICP备19017003号-1 </span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://blog.img.wy1991.cn/static/images/ga.png" style="display:inline-block"></div><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">很帅很愁人~</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="/js/local-search.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f65cb40e9a5d20342ae8b58def42ea5f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.name="baidu_tongji";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:null,display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>