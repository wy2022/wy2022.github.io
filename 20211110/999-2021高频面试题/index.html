<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="keywords" data-name="fire" content="JavaScript,Vue.js,小程序,WebPack,ECMAScript 6,vue,php,js,JavaScript,typescirpt,node,egg,很帅很愁人,web前端,全栈,网页,博客，前端博客,JavaScript,html5,css3,Jquery,NodeJs
"><meta name="360-site-verification" content="178e3a7a27a16a1253976882a4d99509"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/fly-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/fly-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="iy8yHMd-90Qb6NAJqgoij_Cz3i3Jh9FRGRxrWJbRrOw"><meta name="msvalidate.01" content="92E59C28288B8049A45C6288AD39DFA0"><meta name="baidu-site-verification" content="code-etAIIwOVpZ"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.wy1991.cn",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!0,sidebar:{position:"left",display:"hide",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="收集了2021年高频面试题及答案"><meta property="og:type" content="article"><meta property="og:title" content="131-2021高频面试题"><meta property="og:url" content="https://blog.wy1991.cn/20211110/999-2021%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><meta property="og:site_name" content="很帅很愁人~"><meta property="og:description" content="收集了2021年高频面试题及答案"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2e8b6bd0f6443389fdd8173ed97a7b~tplv-k3u1fbpfcp-watermark.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7249773a1634f779c48f3f0ffabf968~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2089718f74b342869de15f01588f033f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30bf2739fec4c29847ba1675c03b62f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c73423b335c34399b4e69b61515365ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03bc9064b8fd4342beb73cfc2c49acea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="article:published_time" content="2021-11-10T02:28:36.000Z"><meta property="article:modified_time" content="2022-06-30T00:33:35.430Z"><meta property="article:author" content="很帅很愁人~"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2e8b6bd0f6443389fdd8173ed97a7b~tplv-k3u1fbpfcp-watermark.awebp"><link rel="canonical" href="https://blog.wy1991.cn/20211110/999-2021%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>131-2021高频面试题 | 很帅很愁人~</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script src="/js/fairyDustCursor.js"></script><script src="/js/clickLove.js"></script></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">很帅很愁人~</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">迷茫是因为才华配不上梦想の，所以你必须非常努力，才能显得毫不费力！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-学习"><a href="/19410322/999999-%E6%9C%89%E7%82%B9%E5%A5%BD%E7%8E%A9/" rel="section"><i class="fa fa-calendar fa-fw"></i>学习</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.wy1991.cn/20211110/999-2021%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/my.jpg"><meta itemprop="name" content="很帅很愁人~"><meta itemprop="description" content="梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="很帅很愁人~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">131-2021高频面试题</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-10 10:28:36" itemprop="dateCreated datePublished" datetime="2021-11-10T10:28:36+08:00">2021-11-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-06-30 08:33:35" itemprop="dateModified" datetime="2022-06-30T08:33:35+08:00">2022-06-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><div class="post-description" style="opacity:0">收集了2021年高频面试题及答案</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="javascript-基础部分"><a href="#javascript-基础部分" class="headerlink" title="javascript 基础部分"></a>javascript 基础部分</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><pre><code>typeof 能够快速区分数据基本结构，缺点就是 不能将 Object, Array,null 区分，都是返回 object
</code></pre><ol><li><p>typeof 的作用?</p><p>区分数据类型，可以返回 7 种数据类型: number,string,boolean,undefined,object,function 以及 es6 新增的 symbol</p></li><li><p>typeof 能正确区分数据类型吗？</p><p>不能。对于基本（原始）类型，除 null 都可以正确判断；对于引用类型，除 function 外，都会返回 object</p></li><li><p>typeof 注意事项</p><ul><li>typeof 返回值为 string 格式</li><li>typeof 未定义的变量不会报错，返回<code>undefined</code></li><li>typeof(null) === “object” 历史遗留的 bug</li><li>tyoeof 无法区分数组和对象 typeof([] === ‘object’)</li><li>tyoeof(NaN) === “number”</li></ul></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre><code>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断
</code></pre><ol><li>instanceof 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。</li><li>instanceof 常用来判断 A 是否为 B 的实例</li></ol><h2 id="typeof-是操作符还是函数"><a href="#typeof-是操作符还是函数" class="headerlink" title="typeof 是操作符还是函数?"></a>typeof 是操作符还是函数?</h2><p>分析: function 是 typeof 返回值之一，如果我们 typeof(typeof) 结果是报错 说明 typeof 并非函数</p><p>既然不是函数，那括号是什么意思？</p><blockquote><p>括号的作用是进行分组而非函数的调用。—— 《javascript 高级程序设计》</p></blockquote><h2 id="typeof-和-instanceof-区别"><a href="#typeof-和-instanceof-区别" class="headerlink" title="typeof 和 instanceof 区别"></a>typeof 和 instanceof 区别</h2><p>typeof 与 instanceof 都是判断数据类型的方法，区别如下：</p><ul><li>typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值</li><li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</li></ul><p>通用检测数据类型，可以采用 Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]” 的字符串</p><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><pre><code>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用

  toString.call(()=&gt;&#123;&#125;)       // [object Function]
  toString.call(&#123;&#125;)           // [object Object]
  toString.call([])           // [object Array]
  toString.call(&#39;&#39;)           // [object String]
  toString.call(22)           // [object Number]
  toString.call(undefined)    // [object undefined]
  toString.call(null)         // [object null]
  toString.call(new Date)     // [object Date]
  toString.call(Math)         // [object Math]
  toString.call(window)       // [object Window]
</code></pre><h2 id="javascript-数据类型"><a href="#javascript-数据类型" class="headerlink" title="javascript 数据类型"></a>javascript 数据类型</h2><blockquote><p>基本数据类型：总共 7 种</p></blockquote><ul><li>Boolean</li><li>Number</li><li>String</li><li>undefined</li><li>null</li><li>bigInt</li><li>symbol</li></ul><blockquote><p>引用类型</p></blockquote><p>Object 对象(包括普通 Object、Function、Array、Date、RegExp、Math)</p><h2 id="的隐式转换规则"><a href="#的隐式转换规则" class="headerlink" title="== 的隐式转换规则"></a>== 的隐式转换规则</h2><ul><li>==: 只需要值相等，无需类型相等；null, undefined 在 == 下互相等且自身等</li><li>== 的转换规则:</li></ul><p>尽量避免使用 ==</p><h2 id="“1”-”2”-”3”-map-parseInt-的输出结果是多少"><a href="#“1”-”2”-”3”-map-parseInt-的输出结果是多少" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)的输出结果是多少"></a>[“1”,”2”,”3”].map(parseInt)的输出结果是多少</h2><p>这个网红题考察的就是 parseInt 有两个参数。 map 传入的函数可执行三个参数：</p><pre><code>  // ele   遍历的元素
  // index 遍历的元素索引
  // arr   数组
  arr.map(function(ele, index, arr)&#123;&#125;)
</code></pre><p>[‘1’,’2’,’3’].map(parseInt)相当于执行了以下三次过程：</p><pre><code>  parseInt(&#39;1&#39;, 0, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])
  parseInt(&#39;2&#39;, 1, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])
  parseInt(&#39;3&#39;, 2, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])
</code></pre><ul><li>parseInt(‘1’, 0, [‘1’,’2’,’3’]): radix 为 0 时，默认取 10，最后返回 1</li><li>parseInt(‘2’, 1, [‘1’,’2’,’3’]): radix 取值为 2~36，返回 NaN</li><li>parseInt(‘3’, 2, [‘1’,’2’,’3’]): radix 取值为 2，二进制只包括 0，1，返回 NaN</li></ul><p>如何让上述代码返回[1,2,3]，使用你能想到的最简单的方案(要求使用[].map())</p><pre><code>  [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(Number)
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcGFyc2VJbnQ=">具体看 parseInt 用法<i class="fa fa-external-link-alt"></i></span></p><h2 id="如何判断数组"><a href="#如何判断数组" class="headerlink" title="如何判断数组"></a>如何判断数组</h2><p>最简单的使用 es6 的 <code>Array.isArray</code></p><p>判断方式</p><pre><code>  // 如果为true，则arr为数组
  arr instanceof Array
</code></pre><p>instanceof 判断数组类型如此之简单，为何不推荐使用那？</p><p>instanceof 操作符的问题在于，如果网页中存在多个 iframe ，那便会存在多个 Array 构造函数，此时判断是否是数组会存在问题。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2NzcwOS9hcnRpY2xlL2RldGFpbHMvMTA1MzAyODUy">参考文章<i class="fa fa-external-link-alt"></i></span></p><h2 id="number-能表示的整数的最大范围"><a href="#number-能表示的整数的最大范围" class="headerlink" title="number 能表示的整数的最大范围"></a>number 能表示的整数的最大范围</h2><ul><li><p>安全的整数范围：15 位数以下</p></li><li><p>JavaScript 并不能表示任意位的整数，最大的整数是 Number.MAX_SAFE_INTEGER(9007199254740991)，最小的整数是 Number.MIN_SAFE_INTEGER(-9007199254740991)</p></li><li><p>特别注意，很多 ID 是超出这个范围的，所以 ID 最好是用 string，当 ID 超出 15 位数的话，就肯定要用字符串类型了。</p></li><li><p>超出会失准</p><pre><code>var a = 9007199254740995
a; // 9007199254740996
</code></pre></li></ul><h2 id="2-toFixed-会输出什么结果"><a href="#2-toFixed-会输出什么结果" class="headerlink" title="2.toFixed() 会输出什么结果"></a>2.toFixed() 会输出什么结果</h2><p>会报错 <code>Uncaught SyntaxError: Invalid or unexpected token</code>，<code>.</code> 会被看做小数点，正确调用方式<code>(2).toFixed()</code></p><h2 id="查询某个对象是否有某个属性的方法"><a href="#查询某个对象是否有某个属性的方法" class="headerlink" title="查询某个对象是否有某个属性的方法"></a>查询某个对象是否有某个属性的方法</h2><p>使用 in 关键字,该方法可以判断对象的自有属性和继承来的属性是否存在。</p><h2 id="splice-和-slice-你能说说有啥用和区别吗"><a href="#splice-和-slice-你能说说有啥用和区别吗" class="headerlink" title="splice 和 slice 你能说说有啥用和区别吗"></a>splice 和 slice 你能说说有啥用和区别吗</h2><p>slice：截取功能</p><ul><li>截取数组为主，也可以截取字符串</li><li>返回新的数组，包含截取的元素</li><li>不改变原数组</li></ul><p>splice()：数组增删查改</p><ul><li>只能对数组增删查改，字符串无效</li><li>返回新的数组，内容是被删除的元素</li><li>会改变原数组</li></ul><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a>==和===区别</h2><ul><li>=== 是严格相等，要求数据类型和值都要相等；== 只需要值相等。</li><li>== 会发生隐式类型转换，=== 不会发生隐式类型转换。</li></ul><h2 id="JS-中构造函数与普通函数的区别"><a href="#JS-中构造函数与普通函数的区别" class="headerlink" title="JS 中构造函数与普通函数的区别"></a>JS 中构造函数与普通函数的区别</h2><ol><li><p>调用方式不一样</p><p>//构造函数也是一个普通函数，创建方式和普通函数一样。<br>function Foo(){}<br>Foo();//普通函数调用方式<br>var f = new Foo();//构造函数调用方式</p></li></ol><ul><li>普通函数调用方式：直接调用 person();</li><li>构造函数调用方式：需要使用 new 关键字来调用 new person();</li></ul><ol start="2"><li><p>作用也不一样（构造函数用来新建实例对象）</p></li><li><p>首字母大小写习惯</p></li></ol><ul><li>一般构造函数的函数名称会用大写</li><li>普通函数用小写</li></ul><ol start="4"><li>函数中 this 的指向不同</li></ol><ul><li>普通函数中的 this，在严格模式下指向 undefined，非严格模式下指向 window 对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>===<span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//代码运行结果：true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>构造函数的 this 则是指向它创建的对象实例。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;令狐冲&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f.name);</span><br><span class="line"><span class="comment">//代码运行结果：令狐冲</span></span><br><span class="line"><span class="comment">//补充：构造函数的函数名和类名相同：Foo()这个构造函数，Foo是函数名，也是这个对象的类名。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>写法的不同</li></ol><p>构造函数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(<span class="type">name</span>)&#123;</span><br><span class="line">	this.name = <span class="type">name</span>;</span><br><span class="line">&#125;</span><br><span class="line">var p = <span class="built_in">new</span> Person(<span class="string">&#x27;John&#x27;</span>);//使用<span class="built_in">new</span>关键字，不使用<span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	obj.name = name;</span><br><span class="line">	<span class="keyword">return</span> obj;<span class="comment">//使用return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = person(<span class="string">&#x27;john&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function person(name)&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//使用return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = person(<span class="string">&#x27;john&#x27;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类数组与数组区别，为什么要设置类数组"><a href="#类数组与数组区别，为什么要设置类数组" class="headerlink" title="类数组与数组区别，为什么要设置类数组"></a>类数组与数组区别，为什么要设置类数组</h2><p>类数组</p><ul><li>所谓类数组对象，就是指可以通过索引属性访问元素并且拥有 length 属性的对象。</li></ul><p>类数组与数组区别</p><ul><li>类数组不具备数组的方法(splice，split，push..)</li><li>类数组是一个普通对象，数组类型是 Array<br>为什么设置类数组</li><li>类数组对象的设计目的更多是只让你遍历和访问下标,而不是去添加或删除元素</li></ul><h2 id="null-与-undefined-的区别"><a href="#null-与-undefined-的区别" class="headerlink" title="null 与 undefined 的区别"></a>null 与 undefined 的区别</h2><ul><li>null 表示一个”无”的对象，也就是该处不应该有值；而 undefined 表示未定义。</li><li>在转换为数字时结果不同，Number(null)为 0，而 undefined 为 NaN。</li></ul><p>使用场景上：</p><ol><li>null：</li></ol><ul><li>作为函数的参数，表示该函数的参数不是对象</li><li>作为对象原型链的终点</li></ul><ol start="2"><li>undefined:</li></ol><ul><li>变量声明未赋值，等于 undefined</li><li>调用函数时，未提供参数值，该参数等于 undefined</li><li>对象没有赋值属性，该属性的值为 undefined</li><li>函数没有返回值时，默认返回 undefined</li></ul><h1 id="JavaScript-深入部分"><a href="#JavaScript-深入部分" class="headerlink" title="JavaScript 深入部分"></a>JavaScript 深入部分</h1><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><ul><li><p>默认绑定: 非严格模式下 this 指向全局对象，严格模式下 this 会绑定为 undefined</p></li><li><p>隐式绑定: 满足 XXX.fn() 格式，fn 的 this 指向 XXX。如果存在链式调用， this 永远指向最后调用它的那个对象 隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</p></li><li><p>显式绑定: 通过 call/apply/bind 修改 this 指向</p></li><li><p>new 绑定: 通过 new 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 this 。</p></li><li><p>箭头函数绑定: 箭头函数没有 this ，它的 this 是通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时<br>优先级</p></li></ul><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><a href="https://blog.wy1991.cn/20210629/22-js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型与原型链</a></p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ol><li><p>代码开始执行，创建一个全局调用栈，script 作为宏任务执行</p></li><li><p>执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列</p></li><li><p>同步任务执行完毕，查看微任务队列</p><ul><li>若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)</li><li>若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空</li></ul></li></ol><p><a href="https://blog.wy1991.cn/20210627/19-JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-eventLoop/">参考链接</a></p><h2 id="谈谈对作用域链的理解"><a href="#谈谈对作用域链的理解" class="headerlink" title="谈谈对作用域链的理解"></a>谈谈对作用域链的理解</h2><p>词法作用域与动态作用域等名词，以及对 this 的理解。可以去阅读<code>你不知道的 JavaScript（上卷）</code></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMDM2MDkxL2FydGljbGUvZGV0YWlscy8xMjA0NDE5ODI=">参考链接<i class="fa fa-external-link-alt"></i></span></p><h2 id="谈谈你对闭包的理解"><a href="#谈谈你对闭包的理解" class="headerlink" title="谈谈你对闭包的理解"></a>谈谈你对闭包的理解</h2><p><a href="https://blog.wy1991.cn/20210628/74-%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8A%E9%97%AD%E5%8C%85/">参考链接</a></p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><blockquote><p><code>JavaScript</code>是解释性语言，也就是说，编译一行，执行一行，但<code>js</code>并非上来就进入编译环节，它在编译之前存在预编译过程。</p></blockquote><p><code>js</code>中预编译一般有两种：全局的预编译和函数的预编译，分别发生在<code>script</code>内代码执行前和函数的执行前。</p><p>在学习<code>JavaScript</code>预编译之前，先了解一下<code>JavaScript</code>从编译到执行的过程，大致可分为四步：</p><ol><li>词法分析</li><li>语法分析：检查代码是否存在错误，若有错误，引擎会抛出语法错误。同时会构建一颗抽象语法树(<code>AST</code>)。</li><li>预编译</li><li>解释执行</li></ol><h3 id="函数预编译"><a href="#函数预编译" class="headerlink" title="函数预编译"></a>函数预编译</h3><p>首先来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>就以上述例子中的<code>a</code>为例，有形参<code>a</code>，变量<code>a</code>，函数<code>a</code>，那<code>test</code>函数执行时，此时的<code>a</code>到底是什么呢？</p><p>输出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ƒ <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">ƒ () &#123;&#125;</span><br></pre></td></tr></table></figure><p>要想弄明白最终的输出结果，就不得不好好学习一下预编译的详细过程。</p><p>在预编译学习中，经常听到一句话：<strong>函数声明整体提升，变量声明提升</strong>。</p><p>这句话可以解决大多数场景下的预编译面试题，但光凭这句话无法吃透预编译的，因此接下来我们来一起捋一下函数预编译的详细流程。</p><h4 id="函数预编译四部曲"><a href="#函数预编译四部曲" class="headerlink" title="函数预编译四部曲"></a>函数预编译四部曲</h4><ol><li>预编译开始，会建立<code>AO(Activation Object)</code>对象</li><li>找形参和变量声明，使其作为<code>AO</code>的属性名，值赋予<code>undefined</code></li><li>实参和形参相统一(将实参值赋值给形参)</li><li>找函数声明，函数名作为<code>AO</code>属性名，值赋予函数体</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>学习了函数的预编译过程，就可以回头细细的品味一下上面的案例：</p><ol><li>先建立<code>AO</code>，并找形参和变量声明，值赋予<code>undefined</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AO :&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>形参实参相统一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AO :&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>找函数声明，值赋予函数体<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO :&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>预编译过程结束，挨着分析一下<code>console</code>的打印结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个<span class="built_in">console</span>.log(a); <span class="comment">// 此时AO中a的值为function a() &#123;&#125;</span></span><br><span class="line">执行赋值操作：</span><br><span class="line">    a = <span class="number">123</span> <span class="comment">// AO中的a值修改为123</span></span><br><span class="line">    第二个<span class="built_in">console</span>.log(a) <span class="comment">// 123</span></span><br><span class="line">    第三个<span class="built_in">console</span>.log(a) <span class="comment">// 123</span></span><br><span class="line">    b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// AO中的b值修改为function b()&#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(b) <span class="comment">// function b()&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="全局预编译"><a href="#全局预编译" class="headerlink" title="全局预编译"></a>全局预编译</h3><p>全局中不存在形参和实参，所以全局预编译只需处理变量声明和函数声明。</p><h4 id="全局预编译三部曲"><a href="#全局预编译三部曲" class="headerlink" title="全局预编译三部曲"></a>全局预编译三部曲</h4><ol><li>生成<code>GO(Global Object)</code></li><li>找变量声明，由于全局变量默认挂载在<code>window</code>之上，若<code>window</code>当前已存在当前属性，忽略当前操作，若没有，变量作为属性名，值赋予<code>undefined</code>。</li><li>找函数声明，函数与变量类似，先去<code>window</code>上查看，不存在，函数作为函数名，值为函数体</li></ol><h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><p>将函数预编译案例稍微修改，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test部分的结果与函数部分相同，再次只分析全局部分</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol><li>生成<code>GO</code>，变量提升，函数提升，得到<code>GO</code>如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GO/<span class="built_in">window</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>因此第一个<code>a</code>的值为<code>undefined</code>，随后<code>a</code>赋值为<code>1</code>，所以第二个<code>a</code>的值为<code>1</code></li></ol><blockquote><p>test 中定义了变量 a，因此打印的 a 为自身 AO 中的值。如果 test 中没有定义 a，就会沿着作用域链，当 GO 中查找 a。</p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1. 当函数中出现同样名称的函数名和变量名，编译器真的会先做变量提升再去函数提升吗？这个问题暂时无法验证，如果有大佬知道，希望可以评论告诉一下，谢谢</strong></p><p><strong>2. let/const 声明的变量应当同样进行了变量提升，只不过它与 var 声明的变量做了一定的区分</strong></p><h3 id="常见面试题分析"><a href="#常见面试题分析" class="headerlink" title="常见面试题分析"></a>常见面试题分析</h3><h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  c = <span class="number">234</span></span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line">test()</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure><ol><li><p>生成<code>GO</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="attr">c</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JavaScript 中变量如果未经声明就赋值，会默认将变量挂载到 window 对象上，这也就是所谓的<code>imply global</code>。<code>c</code>就是<code>imply global</code>。</p></blockquote></li><li><p><code>test</code>执行，生成<code>test</code>的<code>AO</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AO还会存储[[scope]]属性，存储AO的作用域链</span></span><br><span class="line"></span><br><span class="line"><span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    [[scope]]: [TestAO, GO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有同学会问，<code>if(a)</code>为 false，if 内部不会执行，那 test 的 AO 中为什么还会有 b 啊？预编译并不是执行，它只不过把变量、函数等进行提升，只有在执行时，才会设计代码逻辑的判断。</p></blockquote></li><li><p>分析<code>test</code>函数执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// AO中b为undefined</span></span><br><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">  <span class="comment">// AO中无a，沿[[scope]]找到GO中的a，值为undefined</span></span><br><span class="line">  b = <span class="number">100</span> <span class="comment">// 不执行</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line">c = <span class="number">234</span> <span class="comment">// AO中没有c属性，沿[[scope]]找到GO中的c修改为234</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 打印的是GO中的c，234</span></span><br><span class="line"><span class="comment">// test执行完毕，AO销毁</span></span><br></pre></td></tr></table></figure></li><li><p>分析剩余代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span> <span class="comment">// GO中的a修改为10</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// GO中c值为234，234</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo)</span><br><span class="line">  <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p><strong>return; 与上面案例的 if 一样，预编译环节不会处理</strong></p><h5 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ƒ <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">ƒ () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">B</span><br><span class="line">ƒ () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h4 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a1 = a</span><br><span class="line">  <span class="keyword">var</span> a = foo</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  a1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h5 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h5><p><code>1</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>预编译的题目多数情况下就可以采用以下原则：</p><ul><li>函数声明，<strong>整体</strong>提升</li><li>变量声明，<strong>声明</strong>提升</li></ul><p>如果遇到复杂的情况，就要按照全局预编译的三部曲和函数预编译的四部曲一步一步推导。</p><p><strong>最后，在预编译时一定要注意</strong>：<code>return、if</code>等代码逻辑判断是在执行时候做的，预编译不管这些，预编译只管变量、形参、函数等。</p><h2 id="new-操作符就做了哪些"><a href="#new-操作符就做了哪些" class="headerlink" title="new 操作符就做了哪些"></a>new 操作符就做了哪些</h2><p>MDN 中对 new 的描述: 使用 new 来构建函数，会执行如下四部操作：</p><ul><li>创建一个空的简单 JavaScript 对象（即 {} ）；</li><li>为步骤 1 新创建的对象添加属性 proto ，将该属性链接至构造函数的原型对象 ；</li><li>将步骤 1 新创建的对象作为 this 的上下文 ；</li><li>如果该函数没有返回对象，则返回 this 。</li></ul><h2 id="你真的了解垃圾回收机制吗"><a href="#你真的了解垃圾回收机制吗" class="headerlink" title="你真的了解垃圾回收机制吗"></a>你真的了解垃圾回收机制吗</h2><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTgxNTg4Mjc2MzU2MzE3MjE0">参考链接<i class="fa fa-external-link-alt"></i></span></p><h2 id="JS-原型链继承与-Class-继承"><a href="#JS-原型链继承与-Class-继承" class="headerlink" title="JS 原型链继承与 Class 继承"></a>JS 原型链继承与 Class 继承</h2><h3 id="基于原型继承"><a href="#基于原型继承" class="headerlink" title="基于原型继承"></a>基于原型继承</h3><p>原型实现继承的核心在于通过子类的构造函数中通过 Parent.call(this)继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5原型链构造对象</span></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="constructor">People(<span class="params">name</span>, <span class="params">age</span>)</span> &#123;</span><br><span class="line">    this.name = name<span class="operator"> || </span>&#x27;pray&#x27;</span><br><span class="line">    this.age = age<span class="operator"> || </span><span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">People</span>.</span></span>prototype.sayHi = <span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">    console.log(this.name + &#x27; <span class="keyword">of</span> &#x27; + this.age + &#x27; sayHi&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5原型链继承对象</span></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//继承父类属性</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">People</span>.</span></span>call(this, name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类方法</span></span><br><span class="line">(<span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建空类</span></span><br><span class="line">    <span class="keyword">let</span> Super = <span class="keyword">function</span> <span class="literal">()</span> &#123; &#125;;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Super</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">People</span>.</span></span>prototype;</span><br><span class="line">    <span class="comment">//父类的实例作为子类的原型</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Super()</span>;</span><br><span class="line">&#125;)<span class="literal">()</span>;</span><br><span class="line"><span class="comment">//修复构造函数指向问题</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype.constructor = Student;</span><br><span class="line"><span class="keyword">let</span> studentObj = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">studentObj.say<span class="constructor">Hi()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于-Class-继承"><a href="#基于-Class-继承" class="headerlink" title="基于 Class 继承"></a>基于 Class 继承</h3><p>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super 继承父类属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 Class构造对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name = <span class="string">&#x27;pray&#x27;</span>, age = <span class="number">18</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; of &#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27; says Hi!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6 extends 继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name = <span class="string">&#x27;student1&#x27;</span>, age = <span class="string">&#x27;22&#x27;</span>, score = <span class="number">90</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//继承父类属性</span></span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="comment">//自身属性</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//继承父类属性方法</span></span><br><span class="line">        <span class="built_in">super</span>.sayHi()</span><br><span class="line">        <span class="comment">//自身方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;score：&#x27;</span> + <span class="built_in">this</span>.score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Student()</span><br><span class="line">person.sayHi()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="call、apply、bind-区别"><a href="#call、apply、bind-区别" class="headerlink" title="call、apply、bind 区别"></a>call、apply、bind 区别</h2><p><a href="https://blog.wy1991.cn/20210629/12-js-call-apply-bind%E5%8C%BA%E5%88%AB/">参考链接</a></p><h2 id="cookie-localStorage-sessionStorage-区别"><a href="#cookie-localStorage-sessionStorage-区别" class="headerlink" title="cookie, localStorage sessionStorage 区别"></a>cookie, localStorage sessionStorage 区别</h2><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可设置失效时间，没有设置的话，默认是关闭浏览器后失效</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>存放数据大小</td><td>4K 左右</td><td>一般为 5MB</td><td>一般为 5MB</td></tr><tr><td>http 请求</td><td>每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td></tr><tr><td>易用性</td><td>需要程序员自己封装，源生的 Cookie 接口不友好</td><td>源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</td><td>源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</td></tr></tbody></table><h2 id="数组高阶方法"><a href="#数组高阶方法" class="headerlink" title="数组高阶方法"></a>数组高阶方法</h2><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDI0MzA1MzY4NTk1NDMxNDU0">参考链接<i class="fa fa-external-link-alt"></i></span></p><h2 id="防抖与节流的区别"><a href="#防抖与节流的区别" class="headerlink" title="防抖与节流的区别"></a>防抖与节流的区别</h2><ul><li><p>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</p></li><li><p>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</p></li></ul><p><a href="https://blog.wy1991.cn/20210627/62-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">参考链接</a></p><h2 id="script-标签的-defer-和-async-属性有什么区别"><a href="#script-标签的-defer-和-async-属性有什么区别" class="headerlink" title="script 标签的 defer 和 async 属性有什么区别"></a>script 标签的 defer 和 async 属性有什么区别</h2><p>MDN 关于 defer 和 async 属性的说明如下：</p><ol><li>不设置 async 和 defer 属性， 那么脚本会同步下载并执行， 阻塞后续 dom 的渲染</li><li>设置了 defer 属性。脚本异步加载，加载完后，在触发 domContentLoaded 事件之前执行。</li><li>设置了 async 属性。脚本异步加载， 加载完后，立即执行，并阻塞后续 dom 渲染。不影响 domContentLoaded 事件的触发</li></ol><h2 id="同步任务与异步任务区别"><a href="#同步任务与异步任务区别" class="headerlink" title="同步任务与异步任务区别"></a>同步任务与异步任务区别</h2><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>同步运行，同步任务是存储在栈上的，每次会同步清楚每个同步任务，一次只能运行一个任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务，这样就会导致线程阻塞。</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>异步模式，即与同步模式相反，异步任务是以队列的形式来储存的，可以一起执行多个任务，函数调用后不会立即返回执行的结果，如果前一个人物需要等待，可先执行后面的任务，等到前置任务结果返回后再继续回调 例：</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>天气冷了，早上刚醒来想喝点热水暖暖身子，但这每天起早贪黑 996，晚上回来太累躺下就睡，没开水啊，没法子，只好急急忙忙去烧水。<br>现在早上太冷了啊，不由得在被窝里面多躺了一会，收拾的时间紧紧巴巴，不能空等水开，于是我便趁此去洗漱，收拾自己。<br>洗漱完，水开了，喝到暖暖的热水，舒服啊！<br>舒服完，开启新的 996 之日，打工人出发！<br>烧水和洗漱是在同时间进行的，这就是<strong>计算机中的异步</strong>。<br><strong>计算机中的同步</strong>是连续性的动作，上一步未完成前，下一步会发生堵塞，直至上一步完成后，下一步才可以继续执行。例如：只有等水开，才能喝到暖暖的热水。</p><h2 id="使用-new-调用函数，而这个函数中有-return，那它-return-出来的是什么"><a href="#使用-new-调用函数，而这个函数中有-return，那它-return-出来的是什么" class="headerlink" title="使用 new 调用函数，而这个函数中有 return，那它 return 出来的是什么"></a>使用 new 调用函数，而这个函数中有 return，那它 return 出来的是什么</h2><p><strong>构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象；否则返回 new 创建的对象</strong></p><p>下面为测试部分</p><h3 id="返回值为基本类型"><a href="#返回值为基本类型" class="headerlink" title="返回值为基本类型"></a>返回值为基本类型</h3><p>假设构造函数返回值为一个基本类型，我们来看一下最后的返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thin_User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;i will keep thin forever&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thin_User.prototype.eatToMuch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i eat so much, but i&#x27;m very thin!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thin_User.prototype.isThin = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaobao = <span class="keyword">new</span> Thin_User(<span class="string">&#x27;zcxiaobao&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(xiaobao.name) <span class="comment">// zcxiaobao</span></span><br><span class="line"><span class="built_in">console</span>.log(xiaobao.age) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(xiaobao.isThin) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// i eat so much, but i&#x27;m very thin!!!</span></span><br><span class="line">xiaobao.eatToMuch()</span><br></pre></td></tr></table></figure><p>最后的返回结果好像受到任何干扰，难道构造函数不会对返回值进行处理吗？<br>不急，我们来接着测试一下返回值为对象的情况。</p><h3 id="返回值为对象"><a href="#返回值为对象" class="headerlink" title="返回值为对象"></a>返回值为对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thin_User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age * <span class="number">10</span>,</span><br><span class="line">    <span class="attr">fat</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thin_User.prototype.eatToMuch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 白日做梦吧，留下肥胖的泪水</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i eat so much, but i&#x27;m very thin!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thin_User.prototype.isThin = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaobao = <span class="keyword">new</span> Thin_User(<span class="string">&#x27;zcxiaobao&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// Error: xiaobao.eatToMuch is not a function</span></span><br><span class="line">xiaobao.eatToMuch()</span><br></pre></td></tr></table></figure><p>当我执行 eatToMuch 时，控制台直接报错，没有当前函数，于是我打印了 xiaobao 对象：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2e8b6bd0f6443389fdd8173ed97a7b~tplv-k3u1fbpfcp-watermark.awebp"></p><p>发现 xiaobao 对象的 age 发生了改变，而且增加了 fat 属性，正好与构造函数的返回值一样。</p><h2 id="什么是-promise？实现一个简单的-promise"><a href="#什么是-promise？实现一个简单的-promise" class="headerlink" title="什么是 promise？实现一个简单的 promise"></a>什么是 promise？实现一个简单的 promise</h2><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNjA3OTY4NDgxMjg3">参考文章<i class="fa fa-external-link-alt"></i></span></p><h2 id="vue3-为什么抛弃了-Object-definePropetry-采用-proxy"><a href="#vue3-为什么抛弃了-Object-definePropetry-采用-proxy" class="headerlink" title="vue3 为什么抛弃了 Object.definePropetry 采用 proxy"></a>vue3 为什么抛弃了 Object.definePropetry 采用 proxy</h2><ol><li>Object.defineProperty 无法监控到数组下标的变化(其实是可以的，只是考虑到性能/体验的性价比，所以放弃了这个特性)，导致数组追加元素，不能实时响应（为了解决这个问题，Vue2 重写了几个数组方法 比如:<code>push</code>,<code>pop</code>….）</li><li>Object.defineProperty 只能劫持对象的属性，需要对每个对象属性进行遍历，如果属性是对象，还需要深度遍历。proxy 可以劫持整个对象，并返回一个新的对象</li><li>proxy 不仅可以代理对象，还能代理数组，还可以代理动态增加的属性</li></ol><h2 id="vue-中双向绑定和-vuex-冲突怎么办"><a href="#vue-中双向绑定和-vuex-冲突怎么办" class="headerlink" title="vue 中双向绑定和 vuex 冲突怎么办?"></a>vue 中双向绑定和 vuex 冲突怎么办?</h2><p>例子: <code>&lt;input v-model=&quot;obj.message&quot;&gt;</code><br>场景：obj 是计算属性中返回的一个 vuex store 对象，如果在严格模式下，v-model 直接修改 obj.message 会报错，</p><p>可以使用 <code>计算属性</code> <code>get</code> <code>set</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">&#x27;updateMessage&#x27;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly92dWV4LnZ1ZWpzLm9yZy96aC9ndWlkZS9mb3Jtcy5odG1sIyVFNSU4RiU4QyVFNSU5MCU5MSVFNyVCQiU5MSVFNSVBRSU5QSVFNyU5QSU4NCVFOCVBRSVBMSVFNyVBRSU5NyVFNSVCMSU5RSVFNiU4MCVBNw==">参考文档<i class="fa fa-external-link-alt"></i></span></p><h2 id="介绍-HTTPS-握手过程"><a href="#介绍-HTTPS-握手过程" class="headerlink" title="介绍 HTTPS 握手过程"></a>介绍 HTTPS 握手过程</h2><ol><li>客户端使用 https 的 url 访问 web 服务器，要求与服务器建立 ssl 连接</li><li>web 服务器收到客户端请求后，会将网站的证书(包含公钥)传送一份给客户端</li><li>客户端收到网站的证书后会检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个密钥</li><li>客户端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密出会话密钥</li><li>之后服务器与客户端使用密钥加密传输</li></ol><h2 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h2><p>题目如下:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">a</span> = ?;</span><br><span class="line"><span class="keyword">if</span>(<span class="attr">a</span> == <span class="number">1</span> &amp;&amp; <span class="attr">a</span> == <span class="number">2</span> &amp;&amp; <span class="attr">a</span> == <span class="number">3</span>)&#123;</span><br><span class="line"> 	conso.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：<br>可以利用 js == 隐式转换重写 toString</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">a</span> = &#123;</span><br><span class="line">  <span class="attr">i</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">toString</span>()&#123;</span><br><span class="line">    return a.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( <span class="attr">a</span> == <span class="number">1</span> &amp;&amp; <span class="attr">a</span> == <span class="number">2</span> &amp;&amp; <span class="attr">a</span> == <span class="number">3</span> ) &#123;</span><br><span class="line">  console.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么-for-的性能比-forEach-高"><a href="#为什么-for-的性能比-forEach-高" class="headerlink" title="为什么 for 的性能比 forEach 高"></a>为什么 for 的性能比 forEach 高</h2><p>经过测试:</p><ul><li>在 10 万这个级别下， forEach 的性能是 for 的十倍</li><li>在 100 万这个量级下， forEach 的性能是和 for 的一致</li><li>在 1000 万级以上的量级上 ， forEach 的性能远远低于 for 的性能</li></ul><h2 id="使用-JavaScript-Proxy-实现简单的数据绑定"><a href="#使用-JavaScript-Proxy-实现简单的数据绑定" class="headerlink" title="使用 JavaScript Proxy 实现简单的数据绑定"></a>使用 JavaScript Proxy 实现简单的数据绑定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;b id=<span class="string">&quot;count&quot;</span>&gt;&lt;/b&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;increase()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;decrease()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value</span>)</span> &#123;</span><br><span class="line">    target[property] = value;</span><br><span class="line">    render(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">render(proxy.count);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;count&#x27;</span>).innerHTML = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  proxy.count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrease</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  proxy.count -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改"><a href="#已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改" class="headerlink" title="已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改"></a>已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attribute">style</span>=<span class="string">&quot;width:480px!important;”&gt;</span></span><br></pre></td></tr></table></figure><ol><li>max-width: 300px</li><li>transform: scale(0.625,0.625)</li><li>zoom: 0.625</li></ol><h2 id="如何判断输入的是一个正确的网址"><a href="#如何判断输入的是一个正确的网址" class="headerlink" title="如何判断输入的是一个正确的网址"></a>如何判断输入的是一个正确的网址</h2><p>正则</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function validURL(url) &#123;</span><br><span class="line">  const reg = /^(https?|<span class="type">ftp</span>):\/\/([a-zA-Z0<span class="number">-9.</span>-]+(:[a-zA-Z0<span class="number">-9.</span>&amp;%$-]+)*@)*((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="type">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|<span class="type">1</span>[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;|<span class="type">[1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)(\.(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="type">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|<span class="type">1</span>[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;|<span class="type">[1</span><span class="number">-9</span>]?[<span class="number">0</span><span class="number">-9</span>]))&#123;<span class="number">3</span>&#125;|<span class="type">([a</span>-zA-Z0<span class="number">-9</span>-]+\.)*[a-zA-Z0<span class="number">-9</span>-]+\.(com|<span class="type">edu</span>|<span class="type">gov</span>|<span class="type">int</span>|<span class="type">mil</span>|<span class="type">net</span>|<span class="type">org</span>|<span class="type">biz</span>|<span class="type">arpa</span>|<span class="type">info</span>|<span class="type">name</span>|<span class="type">pro</span>|<span class="type">aero</span>|<span class="type">coop</span>|<span class="type">museum</span>|<span class="type">[a</span>-zA-Z]&#123;<span class="number">2</span>&#125;))(:[<span class="number">0</span><span class="number">-9</span>]+)*(\/($|<span class="type">[a</span>-zA-Z0<span class="number">-9.</span>,?&#x27;\\+&amp;%$#=~<span class="keyword">_</span>-]+))*$/</span><br><span class="line">  <span class="keyword">return</span> reg.test(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现一个-localStorage"><a href="#模拟实现一个-localStorage" class="headerlink" title="模拟实现一个 localStorage"></a>模拟实现一个 localStorage</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageMock = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> store = &#123;&#125;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				<span class="attr">getItem</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> store[key] || <span class="literal">null</span> &#125;,</span><br><span class="line">				<span class="attr">setItem</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123; store[key] = value.toString() &#125;,</span><br><span class="line">				<span class="attr">removeItem</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123; <span class="keyword">delete</span> store[key] &#125;,</span><br><span class="line">				<span class="attr">clear</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; store = &#123;&#125; &#125;,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)()</span><br><span class="line"></span><br><span class="line">		<span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&#x27;localStorage2&#x27;</span>, &#123;</span><br><span class="line">			<span class="attr">value</span>: localStorageMock</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		localStorage2.setItem(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(localStorage2.getItem(<span class="string">&quot;test&quot;</span>))  <span class="comment">//test</span></span><br><span class="line">		localStorage2.removeItem(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(localStorage2.getItem(<span class="string">&quot;test&quot;</span>))  <span class="comment">//null</span></span><br><span class="line">		localStorage2.setItem(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">		localStorage2.clear()</span><br><span class="line">		<span class="built_in">console</span>.log(localStorage2.getItem(<span class="string">&quot;test&quot;</span>))  <span class="comment">//null</span></span><br><span class="line">    <span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="已知数据格式，实现一个函数-fn-找出链条中所有的父级-id"><a href="#已知数据格式，实现一个函数-fn-找出链条中所有的父级-id" class="headerlink" title="已知数据格式，实现一个函数 fn 找出链条中所有的父级 id"></a>已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</span></span><br><span class="line"><span class="comment">* 实现： 通过es6的class实现，思路：递归调用，下传当前的父辈的id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindFather</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">this</span>.<span class="keyword">init</span>(),</span><br><span class="line">        <span class="keyword">this</span>.target = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(value,<span class="keyword">data</span>,idArr) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">data</span>.forEach((item, index) =&gt; &#123;</span><br><span class="line">            item.idArr = idArr.concat(item.id)</span><br><span class="line">            <span class="keyword">if</span>(item.id === value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.target = item.idArr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(item.children)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.dfs(value, item.children, item.idArr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    result() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> [&#123;</span><br><span class="line">            id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    id: <span class="string">&#x27;11&#x27;</span>,</span><br><span class="line">                    name: <span class="string">&#x27;test11&#x27;</span>,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">                            name: <span class="string">&#x27;test111&#x27;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: <span class="string">&#x27;112&#x27;</span>,</span><br><span class="line">                            name: <span class="string">&#x27;test112&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">                    name: <span class="string">&#x27;test12&#x27;</span>,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: <span class="string">&#x27;121&#x27;</span>,</span><br><span class="line">                            name: <span class="string">&#x27;test121&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> find = new FindFather();</span><br><span class="line">find.dfs(<span class="string">&#x27;112&#x27;</span>,find.<span class="keyword">data</span>, [])</span><br><span class="line">console.log(find.result())  <span class="comment">//[&quot;1&quot;,&quot;12&quot;,&quot;121&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="v-if、v-show、v-html-的原理是什么，它是如何封装的"><a href="#v-if、v-show、v-html-的原理是什么，它是如何封装的" class="headerlink" title="v-if、v-show、v-html 的原理是什么，它是如何封装的"></a>v-if、v-show、v-html 的原理是什么，它是如何封装的</h2><ul><li>v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染；</li><li>v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display；</li><li>v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHTML 为 v-html 的值</li></ul><h2 id="input-搜索如何防抖，如何处理中文输入"><a href="#input-搜索如何防抖，如何处理中文输入" class="headerlink" title="input 搜索如何防抖，如何处理中文输入"></a>input 搜索如何防抖，如何处理中文输入</h2><p>看过 element 源码的同学们 应该知道， compositionstart &amp; compositionend 来处理中文</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line"><span class="keyword">ref</span>=<span class="string">&quot;input&quot;</span></span><br><span class="line"><span class="keyword">@compositionstart</span>=<span class="string">&quot;handleComposition&quot;</span></span><br><span class="line"><span class="keyword">@compositionupdate</span>=<span class="string">&quot;handleComposition&quot;</span></span><br><span class="line"><span class="keyword">@compositionend</span>=<span class="string">&quot;handleComposition&quot;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ul><li>输入到 input 框触发 input 事件</li><li>失去焦点后内容有改变触发 change 事件</li><li>识别到你开始使用中文输入法触发**compositionstart 事件</li><li>未输入结束但还在输入中触发 compositionupdate **事件</li><li>输入完成（也就是我们回车或者选择了对应的文字插入到输入框的时刻）触发 compositionend 事件。</li></ul><h2 id="vue-是如何对数组方法进行变异的？例如-push、pop、splice-等方法"><a href="#vue-是如何对数组方法进行变异的？例如-push、pop、splice-等方法" class="headerlink" title="vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法"></a>vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</h2><ol><li>为什么要对数组进行单独处理</li></ol><p>在 Vue 现有阶段中，对响应式处理利用的是 Object.defineProperty 对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以我们需要对这些操作进行 hack，让 vue 能监听到其中的变化。</p><ol start="2"><li>怎么对数组进行处理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cache original method</span></span><br><span class="line">    <span class="comment">// 获取原方法</span></span><br><span class="line">    <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">    <span class="comment">// def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值</span></span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [],</span><br><span class="line">        len = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">      <span class="keyword">var</span> inserted;</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          <span class="comment">// [].push(1),[].unshift(1)</span></span><br><span class="line">          <span class="comment">// arg = [1]</span></span><br><span class="line">          inserted = args;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          <span class="comment">// [1,2,3].splice(0,1,1)</span></span><br><span class="line">          <span class="comment">// 第三个参数为插入的值</span></span><br><span class="line">          inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">      <span class="comment">// 监听变化，如果不是插入操作直接循环响应</span></span><br><span class="line">      <span class="comment">// 如果是去除数组参数方法，触发一次notify将会重新计算</span></span><br><span class="line">      <span class="comment">// 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以</span></span><br><span class="line">      <span class="comment">// 但是如果新增的是一个对象类型，就需要重新监听</span></span><br><span class="line">      <span class="comment">// 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听</span></span><br><span class="line">      <span class="comment">// notify change</span></span><br><span class="line">      ob.dep.notify();</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如该题所问，vue 对 push,pop,splice 等方法进行了 hack，hack 方式很简单，如果加入新对象，对新对象进行响应式化，至于如何响应式化请参考 vue 源码。<br>举例来说对于 push 和 unshift 会推入一个新的对象到数组里(不管从前还是从后),记录这个加入的对象，并调用 Observe 方法将加入的对象转换成响应式对象,对于 splice 方法，如果加入了新对象也是将该对象响应式化。<br>最后一步是向外抛出数组变化，提醒观察者进行更新。</p><ol start="3"><li>存在问题<br>对于 Object.defineProperty 的缺陷导致如果直接改变数组下标是无法 hack 的，由于此点，vue 提供了$set 方法</li></ol><h2 id="vue-如何优化首页的加载速度？vue-首页白屏是什么问题引起的？如何解决呢？"><a href="#vue-如何优化首页的加载速度？vue-首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？"></a>vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</h2><h3 id="首先分析原因"><a href="#首先分析原因" class="headerlink" title="首先分析原因"></a>首先分析原因</h3><p>VUE 首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。</p><h3 id="考虑解决办法"><a href="#考虑解决办法" class="headerlink" title="考虑解决办法"></a>考虑解决办法</h3><ol><li>使用首屏 SSR + 跳转 SPA 方式来优化</li><li>改单页应用为多页应用，需要修改 webpack 的 entry</li><li>改成多页以后使用应该使用 prefetch 的就使用</li><li>处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙</li><li>CDN 资源还是很重要的，最好分开，也能减少一些不必要的资源损耗</li><li>使用 Quicklink，在网速好的时候 可以帮助你预加载页面资源</li><li>骨架屏这种的用户体验的东西一定要上，最好借助 stream 先将这部分输出给浏览器解析</li><li>合理使用 web worker 优化一些计算</li><li>缓存一定要使用，但是请注意合理使用</li><li>大概就这么多，最后可以借助一些工具进行性能评测，重点调优，例如使用 performance 自己实现下等<br>个人意见，如有错误，烦请指正，谢谢！</li></ol><h2 id="TypeScript-中的-never-类型具体有什么用"><a href="#TypeScript-中的-never-类型具体有什么用" class="headerlink" title="TypeScript 中的 never 类型具体有什么用"></a>TypeScript 中的 never 类型具体有什么用</h2><p>举个具体点的例子，当你有一个 union type:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Foo</span> &#123;</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="keyword">Bar</span> &#123;</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">All</span> = Foo | Bar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span><span class="params">(val: All)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (val.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">      <span class="comment">// 这里 val 被收窄为 Foo</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;bar&#x27;</span>:</span><br><span class="line">      <span class="comment">// val 在这里是 Bar</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// val 在这里是 never</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: never = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：type All = Foo | Bar | Baz</p><p>然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。</p><h2 id="Vue-中的-computed-和-watch-的区别在哪里"><a href="#Vue-中的-computed-和-watch-的区别在哪里" class="headerlink" title="Vue 中的 computed 和 watch 的区别在哪里"></a>Vue 中的 computed 和 watch 的区别在哪里</h2><h3 id="computed：计算属性"><a href="#computed：计算属性" class="headerlink" title="computed：计算属性"></a>computed：计算属性</h3><ul><li><p>计算属性是由 data 中的已知值，得到的一个新值。</p></li><li><p>这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。</p></li><li><p>计算属性不在 data 中，计算属性新值的相关已知值在 data 中。</p></li><li><p>别人变化影响我自己。</p></li></ul><h3 id="watch：监听数据的变化"><a href="#watch：监听数据的变化" class="headerlink" title="watch：监听数据的变化"></a>watch：监听数据的变化</h3><ul><li><p>监听 data 中数据的变化</p></li><li><p>监听的数据就是 data 中的已知值</p></li></ul><p>我的变化影响别人</p><ol><li><p>watch 擅长处理的场景：一个数据影响多个数据</p></li><li><p>computed 擅长处理的场景：一个数据受多个数据影响</p></li></ol><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="类数组-arguments-怎么用数组得方法-push-pop-shift-unshift-等"><a href="#类数组-arguments-怎么用数组得方法-push-pop-shift-unshift-等" class="headerlink" title="类数组 arguments 怎么用数组得方法 push pop shift unshift 等"></a>类数组 arguments 怎么用数组得方法 push pop shift unshift 等</h3><ul><li>直接将类数组转换成真正得数组即可，可借助 slice，call</li><li>因为 slice 用于数组切片，参数为，开始下标和长度，如果不传开始为 0，结束为数组长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">const</span> newArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="string">&#x27;zhangsna&#x27;</span>, <span class="string">&#x27;22&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="手写-map"><a href="#手写-map" class="headerlink" title="手写 map"></a>手写 map</h3><ul><li>先想一下 map 使用流程，传入一个可迭代对象，一个回调函数，返回一个数组</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    result.push(fn(item))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newVal = map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">v</span>) =&gt;</span> v * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="手写-every"><a href="#手写-every" class="headerlink" title="手写 every"></a>手写 every</h3><ul><li>先想一下 every 使用流程,传入一个可迭代对象，一个函数，返回 true,boolean</li><li>所有为 true 则返回 true</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">every</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fn(item)) &#123;</span><br><span class="line">      result = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = every([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], <span class="function">(<span class="params">v</span>) =&gt;</span> v &gt;= <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="手写-some"><a href="#手写-some" class="headerlink" title="手写 some"></a>手写 some</h3><ul><li>先想一下 some 用法，传入两个参数，（可迭代对象，回调函数），返回 boolean</li><li>只要有一个 true ,则为 true</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">some</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fn(item)) &#123;</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = some(arr, <span class="function">(<span class="params">v</span>) =&gt;</span> v &gt;= <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="执行一次-once"><a href="#执行一次-once" class="headerlink" title="执行一次 once"></a>执行一次 once</h2><blockquote><p>思路：利用闭包机制，用一个变量来处理是否运行过</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pay = once(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;args&#x27;</span>, args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  pay(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">  pay(<span class="number">100</span>, <span class="number">220</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="模拟-lodash-中的-flowRight"><a href="#模拟-lodash-中的-flowRight" class="headerlink" title="模拟 lodash 中的 flowRight"></a>模拟 lodash 中的 flowRight</h2><ul><li>函数式编程相关</li></ul><p>从右往左依次执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reverse = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reverse()</span><br><span class="line">  <span class="keyword">const</span> first = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> toUpper = <span class="function">(<span class="params">s</span>) =&gt;</span> s.toUpperCase()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写法:1</span></span><br><span class="line">  <span class="comment">// function compose (...args) &#123;</span></span><br><span class="line">  <span class="comment">//   return function (val) &#123;</span></span><br><span class="line">  <span class="comment">//     return args.reverse().reduce((cur, fn) =&gt; fn(cur), val);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">//写法:2</span></span><br><span class="line">  <span class="keyword">const</span> compose =</span><br><span class="line">    <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    <span class="function">(<span class="params">val</span>) =&gt;</span></span><br><span class="line">      args.reverse().reduce(<span class="function">(<span class="params">curr, fn</span>) =&gt;</span> fn(curr), val)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f = compose(toUpper, first, reverse)</span><br><span class="line">  <span class="keyword">const</span> s = f([<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;java&#x27;</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="面试八股文"><a href="#面试八股文" class="headerlink" title="面试八股文"></a>面试八股文</h2><h3 id="1-HTTP-和-HTTPS"><a href="#1-HTTP-和-HTTPS" class="headerlink" title="1. HTTP 和 HTTPS"></a>1. HTTP 和 HTTPS</h3><h4 id="1-http-和-https-的基本概念"><a href="#1-http-和-https-的基本概念" class="headerlink" title="1.http 和 https 的基本概念"></a>1.http 和 https 的基本概念</h4><p>http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。<br>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h4 id="2-http-和-https-的区别及优缺点？"><a href="#2-http-和-https-的区别及优缺点？" class="headerlink" title="2.http 和 https 的区别及优缺点？"></a>2.http 和 https 的区别及优缺点？</h4><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h4 id="3-https-协议的工作原理"><a href="#3-https-协议的工作原理" class="headerlink" title="3.https 协议的工作原理"></a>3.https 协议的工作原理</h4><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk1MTA5NDA3NTQ1NjIyNTQy"># 解读 HTTP1/HTTP2/HTTP3<i class="fa fa-external-link-alt"></i></span></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<code>客户端进入FIN-WAIT-1（终止等待1）状态</code>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ol><p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，<code>服务端就进入了CLOSE-WAIT（关闭等待）状态</code>。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>3）客户端收到服务器的确认请求后，此时，<code>客户端就进入FIN-WAIT-2（终止等待2）状态</code>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p><p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<code>服务器就进入了LAST-ACK（最后确认）状态</code>，等待客户端的确认。</p><p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，<code>客户端就进入了TIME-WAIT（时间等待）状态</code>。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，<code>当客户端撤销相应的TCB后，才进入CLOSED状态</code>。</p><p>6）服务器只要收到了客户端发出的确认，<code>立即进入CLOSED状态</code>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<code>服务器结束TCP连接的时间要比客户端早一些</code>。</p><h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后<code>通过 ACK 回复</code>和<code>超时重发</code>这两个机制来保证。</p><p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol><li>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</li><li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li></ol><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkyNzQzOTk5NzU2ODQ1MDg3"># 深度剖析TCP与UDP的区别<i class="fa fa-external-link-alt"></i></span></p><h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ol><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p><ol><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.src = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 script 生效</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><p><strong>JSONP 的缺点</strong>:<br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p></li><li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p></li><li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></li><li><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></li><li><p><strong>proxy代理</strong> 目前常用方式,通过服务器设置代理</p></li><li><p><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</p></li></ul></li></ol><p>跨域传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDAzMjMyNzY5MTgyNTQ3OTk4"># 跨域，不可不知的基础概念<i class="fa fa-external-link-alt"></i></span></p><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p><ul><li>存储在客户端</li></ul><p><strong>不同点</strong>：</p><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p><strong>粘包出现原因</strong></p><p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p><p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p><p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p><p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p><p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p><p>以上提到的三种措施，都有其不足之处。</p><p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p><p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p><p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p><blockquote><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p></blockquote><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="从输入URL到页面加载的主干流程"></p><ol><li><p>首先在浏览器中输入URL</p></li><li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li><li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li><li><p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p></li><li><p>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p></li><li><p>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p></li><li><p>关闭TCP连接：通过四次挥手释放TCP连接</p></li><li><p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="浏览器渲染流程图"></p></li><li><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul></li></ol><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDA1NDY4NDkxMDY3MTYyNjU1"># DNS域名解析过程<i class="fa fa-external-link-alt"></i></span> ☞<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkyNTk3NzYwOTM1NDYwOTAx"># 浏览器的工作原理<i class="fa fa-external-link-alt"></i></span></p><h3 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h3><ul><li><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h3 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a>如何避免重绘或者重排？</h3><ol><li><p><code>集中改变样式</code>，不要一条一条地修改 DOM 的样式。</p></li><li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>，那么修改他们的 CSS 是不会 reflow 的。</p></li><li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li><li><p>尽量只修改<code>position：absolute</code>或<code>fixed</code>元素，对其他元素影响不大</p></li><li><p>动画开始<code>GPU</code>加速，<code>translate</code>使用<code>3D</code>变化</p></li><li><p>提升为合成层</p><p>将元素提升为合成层有以下优点：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">target</span> &#123;</span><br><span class="line">  will-<span class="built_in">change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于合成层的详解请移步<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHA6Ly90YW9iYW9mZWQub3JnL2Jsb2cvMjAxNi8wNC8yNS9wZXJmb3JtYW5jZS1jb21wb3NpdGUv">无线性能优化：Composite<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><h3 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h3><ul><li>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</li><li>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</li><li>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</li></ul><h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片"></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><ul><li><p><strong>强制缓存</strong></p><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p><p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p><strong>协商缓存</strong></p><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果</li></ol></li></ul><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkyODQzMTE3OTYzNTA5Nzkx"># 彻底理解浏览器的缓存机制<i class="fa fa-external-link-alt"></i></span></p><h3 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h3><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><strong>进程和线程的区别与联系</strong></p><p>【区别】：<br>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；<br>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；<br>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>处理机分给线程，即真正在处理机上运行的是线程；<br>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDA1NDY1MzgxNzkxODc1MTA5"># 一文搞懂进程、线程、协程及JS协程的发展<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHA6Ly93d3cuMzYwZG9jLmNvbS9jb250ZW50LzIwLzA0MTcvMTQvMzIxOTY1MDdfOTA2NjI4ODU3LnNodG1s">☞了解更多<i class="fa fa-external-link-alt"></i></span></p><p>关于浏览器传送门 ☞<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkzMDk1MzQ1NTc2MDgzNDg2"># 深入了解现代 Web 浏览器<i class="fa fa-external-link-alt"></i></span></p><h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML &amp;&amp; CSS"></a>HTML &amp;&amp; CSS</h2><h3 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h3><ol><li><p><strong>概念</strong>：</p><p>HTML5的语义化指的是<code>合理正确的使用语义化的标签来创建页面结构</code>。【正确的标签做正确的事】</p></li><li><p><strong>语义化标签</strong>：</p><p>header nav main article section aside footer</p></li><li><p><strong>语义化的优点</strong>:</p><ul><li>在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></li><li><code>代码结构清晰</code>，易于阅读，</li><li><code>利于开发和维护</code> 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li><li><code>有利于搜索引擎优化（SEO）</code>，搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><p><strong>选择器</strong></p><ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel=”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1,p)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul><p><strong>优先级：</strong></p><ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器/属性选择器/伪类选择器（0010）</li><li>元素选择器/伪元素选择器（0001）</li><li>关系选择器/通配符选择器（0000）</li></ul><p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：<code>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h3 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h3><p><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p><p><strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p><p><strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p><p><strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p><p><strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><p>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit</p><p><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</p><p><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</p><p><strong>inherit</strong>：继承父元素的 box-sizing 值。</p><h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，<code>width 指 content 部分的宽度</code>。<br>在 IE 盒子模型中，<code>width 表示 content+padding+border 这三个部分的宽度</code>。</p><p>故在计算盒子的宽度时存在差异：</p><p><strong>标准盒模型：</strong> 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)</p><p><strong>怪异盒模型：</strong> 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><h3 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h3><p><strong>BFC的概念</strong></p><p><code>BFC</code> 是 <code>Block Formatting Context</code>的缩写，即块级格式化上下文。<code>BFC</code>是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>BFC的原理布局规则</strong></p><ul><li>内部的Box会在<code>垂直方向</code>，一个接一个地放置</li><li>Box<code>垂直方向的距离由margin决定</code>。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反</li><li>BFC的区域<code>不会与float box重叠</code></li><li>BFC是一个独立容器，容器里面的<code>子元素不会影响到外面的元素</code></li><li>计算BFC的高度时，<code>浮动元素也参与计算高度</code></li><li>元素的类型和<code>display属性，决定了这个Box的类型</code>。不同类型的Box会参与不同的<code>Formatting Context</code>。</li></ul><p><strong>如何创建BFC？</strong></p><ul><li>根元素，即HTML元素</li><li>float的值不为none</li><li>position为absolute或fixed</li><li>display的值为inline-block、table-cell、table-caption</li><li>overflow的值不为visible</li></ul><p><strong>BFC的使用场景</strong></p><ul><li>去除边距重叠现象</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>避免某元素被浮动元素覆盖</li><li>避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h3 id="让一个元素水平垂直居中"><a href="#让一个元素水平垂直居中" class="headerlink" title="让一个元素水平垂直居中"></a>让一个元素水平垂直居中</h3><ul><li><p><strong>水平居中</strong></p><ul><li><p>对于 行内元素 : <code>text-align: center</code>;</p></li><li><p>对于确定宽度的块级元素：</p><p>（1）width和margin实现。<code>margin: 0 auto</code>;</p><p>（2）绝对定位和margin-left: (父width - 子width）/2, 前提是父元素position: relative</p></li><li><p>对于宽度未知的块级元素</p><p>（1）<code>table标签配合margin左右auto实现水平居中</code>。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</p><p>（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</p><p>（3）<code>绝对定位+transform</code>，translateX可以移动本身元素的50%。</p><p>（4）flex布局使用<code>justify-content:center</code></p></li></ul></li><li><p><strong>垂直居中</strong></p><ol><li>利用 <code>line-height</code> 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 <code>绝对定位</code>，标签通过margin实现自适应居中</li><li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li><code>table 布局</code>，父级通过转换成表格形式，<code>然后子级设置 vertical-align 实现</code>。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。</li></ol></li></ul><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDA4MzQ4NTI0NTMwMTA2Mzgx"># 图解CSS水平垂直居中常见面试方法<i class="fa fa-external-link-alt"></i></span></p><h3 id="隐藏页面中某个元素的方法"><a href="#隐藏页面中某个元素的方法" class="headerlink" title="隐藏页面中某个元素的方法"></a>隐藏页面中某个元素的方法</h3><p>1.<code>opacity：0</code>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的</p><p>2.<code>visibility：hidden</code>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><p>3.<code>display：none</code>，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p><blockquote><p>该问题会引出 回流和重绘</p></blockquote><h3 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span>:after&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="1-Flex-布局"><a href="#1-Flex-布局" class="headerlink" title="1.Flex 布局"></a>1.Flex 布局</h4><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p><p>容器的属性：</p><ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;</li><li>flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li><li>flex-flow： .box { flex-flow: || ; }</li><li>justify-content：对其方式，水平主轴对齐方式</li><li>align-items：对齐方式，竖直轴线方向</li><li>align-content</li></ul><p>项目的属性（元素的属性）：</p><ul><li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li><li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li><li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小</li><li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li><li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li><li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li><li>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li></ul><h4 id="2-Rem-布局"><a href="#2-Rem-布局" class="headerlink" title="2.Rem 布局"></a>2.Rem 布局</h4><p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p><p><strong>优点</strong>：可以快速适用移动端布局，字体，图片高度</p><p><strong>缺点</strong>：</p><p>①目前 ie 不支持，对 pc 页面来讲使用次数不多；<br>②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；<br>③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。</p><h4 id="3-百分比布局"><a href="#3-百分比布局" class="headerlink" title="3.百分比布局"></a>3.百分比布局</h4><p>通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p><p><strong>缺点</strong>：</p><p>（1）计算困难<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</p><h4 id="4-浮动布局"><a href="#4-浮动布局" class="headerlink" title="4.浮动布局"></a>4.浮动布局</h4><p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p><p><strong>优点</strong></p><p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题</p><p><strong>缺点</strong></p><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，<code>会造成父级元素高度塌陷</code>。</p><h3 id="如何使用rem或viewport进行移动端适配"><a href="#如何使用rem或viewport进行移动端适配" class="headerlink" title="如何使用rem或viewport进行移动端适配"></a>如何使用rem或viewport进行移动端适配</h3><p><strong>rem适配原理：</strong></p><p>改变了一个元素在不同设备上占据的css像素的个数</p><p>rem适配的优缺点</p><ul><li>优点：没有破坏完美视口</li><li>缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)</li></ul><p><strong>viewport适配的原理</strong></p><p>viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的</p><p>viewport适配的优缺点</p><ul><li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li><li>缺点破坏完美视口</li></ul><h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><ul><li>添加额外标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    //添加额外标签并且添加clear属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    //也可以加一个br标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>父级添加overflow属性，或者设置高度</li><li>建立伪类选择器清除浮动</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在css中添加:after伪元素</span></span><br><span class="line">.parent:after&#123;</span><br><span class="line">    <span class="comment">/* 设置添加子元素的内容是空 */</span></span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素为块级元素 */</span></span><br><span class="line">    display: block;</span><br><span class="line">    <span class="comment">/* 设置添加的子元素的高度0 */</span></span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素看不见 */</span></span><br><span class="line">    visibility: hidden;</span><br><span class="line">    <span class="comment">/* 设置clear：both */</span></span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS、TS、ES6"><a href="#JS、TS、ES6" class="headerlink" title="JS、TS、ES6"></a>JS、TS、ES6</h2><h3 id="JS中的8种数据类型及区别"><a href="#JS中的8种数据类型及区别" class="headerlink" title="JS中的8种数据类型及区别"></a>JS中的8种数据类型及区别</h3><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p><p><strong>基本类型(值类型)：</strong> Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中</p><p><strong>引用类型(复杂数据类型)：</strong> Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p><p>传送门 ☞<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDAwNzU0ODEzODAxNzc1MTEx"># JavaScript 数据类型之 Symbol、BigInt<i class="fa fa-external-link-alt"></i></span></p><h3 id="JS中的数据类型检测方案"><a href="#JS中的数据类型检测方案" class="headerlink" title="JS中的数据类型检测方案"></a>JS中的数据类型检测方案</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);            <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>)           <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">console</span>.log());   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型</p><p>缺点：不能将Object、Array和Null区分，都返回object</p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p><p>缺点：Number，Boolean，String基本数据类型不能判断</p><h4 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3.Object.prototype.toString.call()"></a>3.Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                   <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型</p><p>缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="var-amp-amp-let-amp-amp-const"><a href="#var-amp-amp-let-amp-amp-const" class="headerlink" title="var &amp;&amp; let &amp;&amp; const"></a>var &amp;&amp; let &amp;&amp; const</h3><p>ES6之前创建变量用的是var,之后创建变量用的是let/const</p><p><strong>三者区别</strong>：</p><ol><li>var定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。<br>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</li><li>var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</li><li>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;<br>var声明的变量会和GO有映射关系；</li><li><code>会产生暂时性死区</code>：</li></ol><blockquote><p>暂时性死区是浏览器的bug：检测一个未被声明的变量类型时，不会报错，会返回undefined<br>如：console.log(typeof a) //undefined<br>而：console.log(typeof a)//未声明之前不能使用<br>let a</p></blockquote><ol><li>let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</li></ol><h3 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h3><ol><li><p>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p></li><li><p>浏览器垃圾回收机制/内存回收机制:</p><blockquote><p>浏览器的<code>Javascript</code>具有自动垃圾回收机制(<code>GC:Garbage Collecation</code>)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p></blockquote><p><strong>标记清除</strong>:在<code>js</code>中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br><strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br><strong>IE浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。</p></li><li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p><p>（1）堆内存：fn = null 【null：空指针对象】</p><p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p></li><li><p>内存泄漏</p><p>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p></li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;<code>当前创建函数所处的上下文</code>。如果是在全局下创建的函数就是<code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文<code>EC(FN)</code>，供字符串代码执行(进栈执行)</p><p>定义：简单来说作用域就是变量与函数的可访问范围，<code>由当前环境与上层环境的一系列变量对象组成</code><br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。<br>2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是<code>隔离变量</code>，不同作用域下同名变量不会有冲突。</p><p><strong>作用域链参考链接</strong>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h3 id="闭包的两大作用：保存-保护"><a href="#闭包的两大作用：保存-保护" class="headerlink" title="闭包的两大作用：保存/保护"></a>闭包的两大作用：保存/保护</h3><ul><li><p><strong>闭包的概念</strong></p><p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p></li></ul><p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数–《JavaScript高级程序设计》</p></blockquote><p><strong>稍全面的回答</strong>： 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><ul><li><p><strong>闭包的特性</strong>：</p><ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p><p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p><p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li><li><p>2、函数嵌套函数</p></li><li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul></li><li><p><strong>闭包形成的条件</strong>：</p><ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li><p><strong>闭包的用途</strong>：</p><ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li><p><strong>闭包应用场景</strong></p><p>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p></li><li><p><strong>闭包的优点</strong>：延长局部变量的生命周期</p></li><li><p><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li></ul><h3 id="JS-中-this-的五种情况"><a href="#JS-中-this-的五种情况" class="headerlink" title="JS 中 this 的五种情况"></a>JS 中 this 的五种情况</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>基于Function.prototype上的 <code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code> this <code>绑定了传入对象的新函数。这个函数的</code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ol><h3 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型 &amp;&amp; 原型链"></a>原型 &amp;&amp; 原型链</h3><p><strong>原型关系：</strong></p><ul><li>每个 class都有显示原型 prototype</li><li>每个实例都有隐式原型 _ proto_</li><li>实例的_ proto_指向对应 class 的 prototype</li></ul><p>‌ <strong>原型:</strong> 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code> 属性，这个属性指向函数的<code>原型对象</code>。</p><p>原型链：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="new运算符的实现机制"><a href="#new运算符的实现机制" class="headerlink" title="new运算符的实现机制"></a>new运算符的实现机制</h3><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval</span><br></pre></td></tr></table></figure><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h4 id="浏览器中的事件环（Event-Loop"><a href="#浏览器中的事件环（Event-Loop" class="headerlink" title="浏览器中的事件环（Event Loop)"></a><strong>浏览器中的事件环（Event Loop)</strong></h4><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li><p>eventLoop 是由JS的宿主环境（浏览器）来实现的；</p></li><li><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="事件循环流程"></p></li><li><p>浏览器中的任务源(task):</p><ul><li><code>宏任务(macrotask)</code>：<br>宿主环境提供的，比如浏览器<br>ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li><li><code>微任务(microtask)</code>：<br>语言本身提供的，比如promise.then<br>then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li></ul></li></ul><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDAxODgxNzgxMTI1MjUxMDg2"># 宏任务和微任务<i class="fa fa-external-link-alt"></i></span></p><h4 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a><strong>Node 环境中的事件环（Event Loop)</strong></h4><p><code>Node</code>是基于V8引擎的运行在服务端的<code>JavaScript</code>运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="2020120317343116.png"> 执行顺序如下：</p><ul><li><code>timers</code>: 计时器，执行setTimeout和setInterval的回调</li><li><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I/O 回调</li><li><code>idle, prepare</code>: 队列的移动，仅系统内部使用</li><li><code>poll轮询</code>: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate在这里执行</li><li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul><h3 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h3><ol><li><p>setTimeout</p><p>settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p></li><li><p>Promise</p><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li><li><p>async/await</p><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure></li></ol><p>传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk5NjUxMDExMzA0MzU3OTI1"># JavaScript Promise 专题<i class="fa fa-external-link-alt"></i></span></p><h3 id="Async-Await-如何通过同步的方式实现异步"><a href="#Async-Await-如何通过同步的方式实现异步" class="headerlink" title="Async/Await 如何通过同步的方式实现异步"></a>Async/Await 如何通过同步的方式实现异步</h3><p>Async/Await就是一个<strong>自执行</strong>的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象.</p><h3 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h3><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><p><code>防抖</code>：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p><p><code>使用场景</code>：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录上一次函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//记录当前函数触发的时间</span></span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(nowTime - lastTime &gt; delay)&#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.call(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">//同步执行结束时间</span></span><br><span class="line">            lastTime = nowTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;scllor事件被触发了&#x27;</span> + <span class="built_in">Date</span>.now());</span><br><span class="line">&#125;, <span class="number">200</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录上一次的延时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//清除上一次的演示器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">//重新设置新的延时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.apply(<span class="built_in">this</span>);</span><br><span class="line">        &#125;, delay); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="built_in">Date</span>.now());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="简述MVVM"><a href="#简述MVVM" class="headerlink" title="简述MVVM"></a>简述MVVM</h3><p><strong>什么是MVVM？</strong></p><p><code>视图模型双向绑定</code>，是<code>Model-View-ViewModel</code>的缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。Model</code>层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。以前是操作DOM结构更新视图，现在是<code>数据驱动视图</code>。</p><p><strong>MVVM的优点：</strong></p><p>1.<code>低耦合</code>。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；<br>2.<code>可重用性</code>。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。<br>3.<code>独立开发</code>。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。<br>4.<code>可测试</code>。</p><h3 id="Vue底层实现原理"><a href="#Vue底层实现原理" class="headerlink" title="Vue底层实现原理"></a>Vue底层实现原理</h3><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br>Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><p><strong>Observer（数据监听器）</strong> : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><p><strong>Watcher（订阅者）</strong> : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol><p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h3 id="谈谈对vue生命周期的理解？"><a href="#谈谈对vue生命周期的理解？" class="headerlink" title="谈谈对vue生命周期的理解？"></a>谈谈对vue生命周期的理解？</h3><p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ul><li><code>create阶段</code>：vue实例被创建<br><code>beforeCreate</code>: 创建前，此时data和methods中的数据都还没有初始化<br><code>created</code>： 创建完毕，data中有值，未挂载</li><li><code>mount阶段</code>： vue实例被挂载到真实DOM节点<br><code>beforeMount</code>：可以发起服务端请求，去数据<br><code>mounted</code>: 此时可以操作DOM</li><li><code>update阶段</code>：当vue实例里面的data数据变化时，触发组件的重新渲染<br><code>beforeUpdate</code> :更新前<br><code>updated</code>：更新后</li><li><code>destroy阶段</code>：vue实例被销毁<br><code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法<br><code>destroyed</code>:销毁后</li></ul><h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>生命周期（父子组件） 父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount –&gt; 子组件 mounted –&gt; 父组件mounted –&gt;父组件beforeUpdate –&gt;子组件beforeDestroy–&gt; 子组件destroyed –&gt; 父组件updated</p><p><strong>加载渲染过程</strong> 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p><strong>挂载阶段</strong> 父created-&gt;子created-&gt;子mounted-&gt;父mounted</p><p><strong>父组件更新阶段</strong> 父beforeUpdate-&gt;父updated</p><p><strong>子组件更新阶段</strong> 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p><strong>销毁阶段</strong> 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h3 id="computed与watch"><a href="#computed与watch" class="headerlink" title="computed与watch"></a><code>computed与watch</code></h3><p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><p><strong>watch 属性监听</strong> 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p><p><strong>computed 计算属性</strong> 属性的结果会被<code>缓存</code>，当<code>computed</code>中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 <code>computed</code>中的函数必须用<code>return</code>返回最终的结果 <code>computed</code>更高效，优先使用。<code>data 不改变，computed 不更新。</code></p><p><strong>使用场景</strong> <code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p><h3 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h3><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p><h3 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h3><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费（Vue2.x）<br>2.这种场景建议使用 computed，先对数据进行过滤</p><p>注意：3.x 版本中 <code>v-if</code> 总是优先于 <code>v-for</code> 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p><p>解惑传送门 ☞ <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vdjMuY24udnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi92LWlmLXYtZm9yLmh0bWwlMjMlRTYlQTYlODIlRTglQTclODg="># v-if 与 v-for 的优先级对比非兼容<i class="fa fa-external-link-alt"></i></span></p><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ul><li><p>key的作用是为了在diff算法执行时更快的找到对应的节点，<code>提高diff速度，更高效的更新虚拟DOM</code>;</p><p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p></li><li><p>为了在数据变化时强制更新组件，以避免<code>“就地复用”</code>带来的副作用。</p><p>当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p></li></ul><h3 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="headerlink" title="vue组件的通信方式"></a>vue组件的通信方式</h3><ul><li><p><code>props</code>/<code>$emit</code> 父子组件通信</p><p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code> 获取父子组件实例 <code>parent、children</code> <code>Ref</code>获取实例的方式调用组件的属性或者方法 父-&gt;子孙 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li><li><p><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信</p><p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p></li><li><p>vuex 跨级组件通信</p><p>Vuex、<code>$attrs、$listeners</code> <code>Provide、inject</code></p></li></ul><h3 id="nextTick的实现"><a href="#nextTick的实现" class="headerlink" title="nextTick的实现"></a>nextTick的实现</h3><ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol><h3 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h3><p>vue中的插槽是一个非常好用的东西slot说白了就是一个占位的 在vue当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</p><h3 id="keep-alive的实现"><a href="#keep-alive的实现" class="headerlink" title="keep-alive的实现"></a>keep-alive的实现</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</p><p>场景：tabs标签页 后台导航，vue性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin<br>多个组件有相同的逻辑，抽离出来<br>mixin并不是完美的解决方案，会有一些问题<br>vue3提出的Composition API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】<br>场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合<br>劣势：1.变量来源不明确，不利于阅读<br>2.多mixin可能会造成命名冲突 3.mixin和组件可能出现多对多的关系，使得项目复杂度变高</p><h3 id="Vuex的理解及使用场景"><a href="#Vuex的理解及使用场景" class="headerlink" title="Vuex的理解及使用场景"></a>Vuex的理解及使用场景</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p><ol><li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li></ol><p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p><ol><li>State：定义了应用的状态数据</li><li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），</li></ol><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7249773a1634f779c48f3f0ffabf968~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="hooks用过吗？聊聊react中class组件和函数组件的区别"><a href="#hooks用过吗？聊聊react中class组件和函数组件的区别" class="headerlink" title="hooks用过吗？聊聊react中class组件和函数组件的区别"></a>hooks用过吗？聊聊react中class组件和函数组件的区别</h3><p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <code>props</code> 对象并返回一个React元素。</p><p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p><p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p><p><strong>类组件的缺点</strong> :</p><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 <code>this</code> 的工作方式。</p><p><strong>区别</strong>：</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><p>1.状态的有无<br>hooks出现之前，函数组件<code>没有实例</code>，<code>没有生命周期</code>，<code>没有state</code>，<code>没有this</code>，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。</p><p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p><p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p><p><strong>React Hooks（钩子的作用）</strong></p><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>React Hooks的几个常用钩子:</p><ol><li><code>useState()</code> //状态钩子</li><li><code>useContext()</code> //共享状态钩子</li><li><code>useReducer()</code> //action 钩子</li><li><code>useEffect()</code> //副作用钩子</li></ol><p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p><ul><li><p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为class组件render函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Click happened&#x27;</span>)</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p></li><li><p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p></li><li><p>3.useRef 保存引用值</p><p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p></li><li><p>4.useImperativeHandle 穿透 Ref</p><p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p></li><li><p>5.useLayoutEffect 同步执行副作用</p><p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p><p><strong>useEffect和useLayoutEffect有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。<code>官方建议优先使用useEffect</code></p></li></ul><h3 id="React-组件通信方式"><a href="#React-组件通信方式" class="headerlink" title="React 组件通信方式"></a>React 组件通信方式</h3><p>react组件间通信常见的几种情况:</p><ul><li><ol><li>父组件向子组件通信</li></ol></li><li><ol><li>子组件向父组件通信</li></ol></li><li><ol><li>跨级组件通信</li></ol></li><li><ol><li>非嵌套关系的组件通信</li></ol></li></ul><h4 id="1）父组件向子组件通信"><a href="#1）父组件向子组件通信" class="headerlink" title="1）父组件向子组件通信"></a>1）父组件向子组件通信</h4><p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用props就可以获取到这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">props</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;京程一灯&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）子组件向父组件通信"><a href="#2）子组件向父组件通信" class="headerlink" title="2）子组件向父组件通信"></a>2）子组件向父组件通信</h4><p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过props调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">props</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cb = <span class="function"><span class="params">msg</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">          props.callback(msg)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&quot;京程一灯欢迎你!&quot;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">callback</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）跨级组件通信"><a href="#3）跨级组件通信" class="headerlink" title="3）跨级组件通信"></a>3）跨级组件通信</h4><p>即父组件向子组件的子组件通信，向更深层子组件通信。</p><ul><li>使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。</li><li>使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context方式实现跨级组件通信 </span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BatteryContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件的子组件 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;</span></span><br><span class="line"><span class="xml">                    color =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span>&quot;<span class="attr">color</span>&quot;<span class="attr">:color</span>&#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">        ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">GrandChild</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      state = &#123;</span><br><span class="line">          <span class="attr">color</span>:<span class="string">&quot;red&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> &#123;color&#125; = <span class="built_in">this</span>.state</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">          <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span> </span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）非嵌套关系的组件通信"><a href="#4）非嵌套关系的组件通信" class="headerlink" title="4）非嵌套关系的组件通信"></a>4）非嵌套关系的组件通信</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ul><li><ol><li>可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li></ol></li><li><ol><li>可以通过redux等进行全局状态管理</li></ol></li><li><ol><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ol></li><li><ol><li>也可以new一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE的eventBus 就是发布订阅模式，是可以在React中使用的;</li></ol></li></ul><h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 在<code>React事件当中是异步操作</code></p><p>2.同步情况 如果是在<code>setTimeout事件或者自定义的dom事件</code>中，都是同步的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    btnAction = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//不能直接修改state，需要通过setState进行修改</span></span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br><span class="line"><span class="comment">//自定义dom事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">当组件从 <span class="title">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span><br></pre></td></tr></table></figure><h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<code>大量的同步计算任务阻塞了浏览器的 UI 渲染</code>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><ul><li>react内部运转分三层：<ul><li>Virtual DOM 层，描述页面长什么样。</li><li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ul></li></ul><p><code>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：<ul><li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li><li>task，在next tick之前执行</li><li>animation，下一帧之前执行</li><li>high，在不久的将来立即执行</li><li>low，稍微延迟执行也没关系</li><li>offscreen，下一次render时或scroll时才执行</li></ul></li><li>Fiber Reconciler（react ）执行过程分为2个阶段：<ul><li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li><li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li></ul></li><li>Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</li></ul><p>从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><p>传送门 ☞<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDAyMjUwMjU4ODI2NjU3Nzk5"># 深入了解 Fiber<i class="fa fa-external-link-alt"></i></span></p><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建</p><h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><ul><li>加载大组件的时候</li><li>路由异步加载的时候</li></ul><p>react 中要配合 Suspense 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"><span class="keyword">const</span> Box = lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Box&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用组件的时候要用suspense进行包裹</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">    &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React并不是将click事件绑在该div的真实DOM上，而是<code>在document处监听所有支持的事件</code>，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <code>event.preventDefault</code>。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2089718f74b342869de15f01588f033f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="react事件绑定原理"></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="webpack-做过哪些优化，开发效率方面、打包策略方面等等"><a href="#webpack-做过哪些优化，开发效率方面、打包策略方面等等" class="headerlink" title="webpack 做过哪些优化，开发效率方面、打包策略方面等等"></a>webpack 做过哪些优化，开发效率方面、打包策略方面等等</h3><p><strong>1）优化 Webpack 的构建速度</strong></p><ul><li>使用高版本的 Webpack （使用webpack4）</li><li>多线程/多实例构建：HappyPack(不维护了)、thread-loader</li><li>缩小打包作用域：<ul><li>exclude/include (确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li>IgnorePlugin (完全排除模块)</li><li>合理使用alias</li></ul></li><li>充分利用缓存提升二次构建速度：<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin<br>注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader</li></ul></li><li>DLL：<ul><li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li></ul></li></ul><p>2）使用webpack4-优化原因</p><ul><li>(a)V8带来的优化（for of替代forEach、Map和Set替代Object、includes替代indexOf）</li><li>(b)默认使用更快的md4 hash算法</li><li>(c)webpacks AST可以直接从loader传递给AST，减少解析时间</li><li>(d)使用字符串方法替代正则表达式</li></ul><p>①noParse</p><ul><li>不去解析某个库内部的依赖关系</li><li>比如jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西</li><li>在独立库的时候可以使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery/</span>,</span><br><span class="line">    rules:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②IgnorePlugin</p><ul><li>忽略掉某些内容 不去解析依赖库内部引用的某些内容</li><li>从moment中引用 ./locol 则忽略掉</li><li>如果要用local的话 则必须在项目中必须手动引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;moment/locale/zh-cn&#x27;</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> Webpack.IgnorePlugin(<span class="regexp">/./</span>local/, <span class="regexp">/moment/</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③dillPlugin</p><ul><li>不会多次打包， 优化打包时间</li><li>先把依赖的不变的库打包</li><li>生成 manifest.json文件</li><li>然后在webpack.config中引入</li><li>webpack.DllPlugin Webpack.DllReferencePlugin</li></ul><p>④happypack -&gt; thread-loader</p><ul><li>大项目的时候开启多线程打包</li><li>影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。</li></ul><p>⑤thread-loader<br>thread-loader 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。<br>把这个 loader 放置在其他 loader 之前（如下图 example 的位置）， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">&quot;src&quot;</span>),</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&quot;thread-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 你的高开销的loader放置在此 (e.g babel-loader)</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的loader中使用，否则效果不佳</p><p>⑥压缩加速——开启多线程压缩</p><ul><li>不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr没人合并。<br>Webpack 4.0以前：uglifyjs-webpack-plugin，parallel参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,&#125;;</span><br></pre></td></tr></table></figure><ul><li>推荐使用 terser-webpack-plugin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [<span class="keyword">new</span> TerserPlugin(</span><br><span class="line">      parallel: <span class="literal">true</span>   <span class="comment">// 多线程</span></span><br><span class="line">    )],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2）优化 Webpack 的打包体积</strong></p><ul><li>压缩代码</li><li>提取页面公共资源：</li><li>Tree shaking</li><li>Scope hoisting</li><li>图片压缩</li><li>动态Polyfill</li></ul><p><strong>3）speed-measure-webpack-plugin</strong><br>简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。 <strong>开发阶段</strong></p><p>开启多核压缩 插件：** terser-webpack-plugin **</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">                    <span class="attr">ecma</span>: <span class="number">6</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ☞<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk2MTg4ODU2MTY0ODEwNzg5"># 工程化专题<i class="fa fa-external-link-alt"></i></span></p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="简单描述一下-Babel-的编译过程"><a href="#简单描述一下-Babel-的编译过程" class="headerlink" title="简单描述一下 Babel 的编译过程"></a>简单描述一下 Babel 的编译过程</h3><p>Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p><p><code>Babel</code> 本质上就是在操作 <code>AST</code> 来完成代码的转译。AST是抽象语法树（Abstract Syntax Tree, AST）</p><p>如果想要了解更多，可以阅读和尝试：</p><ul><li>分析 <code>AST</code>：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vYXN0ZXhwbG9yZXIubmV0Lw==">ASTexplorer.net<i class="fa fa-external-link-alt"></i></span></li><li><code>AST</code> 规范：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVl">github.com/estree/estr…<i class="fa fa-external-link-alt"></i></span></li></ul><p><code>Babel</code> 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p><ol><li><strong>解析（Parse）</strong> ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li><li><strong>转换（Transform）</strong> ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li><li><strong>生成（Generate）</strong> ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li></ol><p>经过这三个阶段，代码就被 <code>Babel</code> 转译成功了。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30bf2739fec4c29847ba1675c03b62f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c73423b335c34399b4e69b61515365ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h3><p>查看分支：git branch<br>创建分支：git branch<br>切换分支：git checkout<br>创建+切换分支：git checkout -b<br>合并某分支到当前分支：git merge<br>删除分支：git branch -d</p><h3 id="如何使用Git管理项目"><a href="#如何使用Git管理项目" class="headerlink" title="如何使用Git管理项目"></a>如何使用Git管理项目</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03bc9064b8fd4342beb73cfc2c49acea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>实际开发中，一个仓库（一般只放一个项目）主要存在两条主分支：master与develop分支。这个两个分支的生命周期是整个项目周期。</p><p>我们可能使用的不同类型的分支对项目进行管理是：</p><ul><li><p>功能分支 功能分支（或有时称为主题分支）用于为即将发布或遥远的未来版本开发新功能。在开始开发某个功能时，将包含该功能的目标版本在那时很可能是未知的。功能分支的本质在于，只要该功能处于开发阶段，它就存在，但最终会被合并回<code>develop</code>（明确将新功能添加到即将发布的版本中）或丢弃。功能分支通常只存在于开发者仓库中，而不存在于<code>origin</code>。</p></li><li><p>发布分支 发布分支支持准备新的生产版本。它们允许在最后一刻打点 i 和交叉 t。此外，它们允许修复小错误并为发布准备元数据（版本号、构建日期等）。通过在发布分支上完成所有这些工作，该<code>develop</code> 分支被清除以接收下一个大版本的功能。</p><ul><li>从<code>develop</code>分支拉取，且必须合并回 <code>develop</code> 和 <code>master</code></li><li>分支命名约定：<code>release-*</code></li></ul></li><li><p>修补程序分支</p><p>Hotfix 分支与发布分支非常相似，因为它们也旨在为新的生产版本做准备，尽管是计划外的。它们产生于需要立即对现场制作版本的不良状态采取行动。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上的相应标记中分支出一个修补程序分支。</p></li></ul><p><strong>master</strong>：这个分支最为稳定，这个分支表明项目处于可发布的状态。<br><strong>develop</strong>：做为开发的分支，平行于master分支。<br><strong>Feature branches</strong>：这种分支和咱们程序员平常开发最为密切，称做功能分支。必须从develop分支建立，完成后合并回develop分支。<br><strong>Release branches</strong>：这个分支用来分布新版本。从develop分支建立，完成后合并回develop与master分支。这个分支上能够作一些很是小的bug修复，固然，你也能够禁止在这个分支作任何bug的修复工做，而只作版本发布的相关操做，例如设置版本号等操做，那样的话那些发现的小bug就必须放到下一个版本修复了。若是在这个分支上发现了大bug，那么也绝对不能在这个分支上改，须要Featrue分支上改，走正常的流程。<br><strong>Hotfix branches</strong>：这个分支主要为修复线上特别紧急的bug准备的。必须从master分支建立，完成后合并回develop与master分支。这个分支主要是解决线上版本的紧急bug修复的，例如忽然版本V0.1上有一个致命bug，必须修复。那么咱们就能够从master 分支上发布这个版本那个时间点 例如 tag v0.1（通常代码发布后会及时在master上打tag），来建立一个 hotfix-v0.1.1的分支，而后在这个分支上改bug，而后发布新的版本。最后将代码合并回develop与master分支。</p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vbnZpZS5jb20vcG9zdHMvYS1zdWNjZXNzZnVsLWdpdC1icmFuY2hpbmctbW9kZWwv">更多请参考<i class="fa fa-external-link-alt"></i></span></p><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><p><code>移除生产环境的控制台打印</code>。方案很多，esling+pre-commit、使用插件自动去除，插件包括babel-plugin-transform-remove-console、uglifyjs-webpack-plugin、terser-webpack-plugin。最后选择了terser-webpack-plugin，脚手架vue-cli用这个插件来开启缓存和多线程打包，无需安装额外的插件，仅需在configureWebpack中设置terser插件的drop_console为true即可。最好还是养成良好的代码习惯，在开发基本完成后去掉无用的console，vscode中的turbo console就蛮好的。</p><p><code>第三方库的按需加载</code>。echarts，官方文档里是使用配置文件指定使用的模块，另一种使用babel-plugin-equire实现按需加载。element-ui使用babel-plugin-component实现按需引入。</p><p>前后端数据交换方面，推动项目组使用蓝湖、接口文档，与后端同学协商，规范后台数据返回。</p><p>雅虎军规提到的，<code>避免css表达式、滤镜，较少DOM操作，优化图片、精灵图，避免图片空链接等</code>。</p><p><code>性能问题：页面加载性能、动画性能、操作性能</code>。Performance API，记录性能数据。</p><p>winter重学前端 优化技术方案：</p><p>缓存：<code>客户端控制的强缓存策略</code>。</p><p><code>降低请求成本</code>：DNS 由客户端控制，隔一段时间主动请求获取域名IP，不走系统DNS（完全看不懂）。TCP/TLS连接复用，服务器升级到HTTP2，尽量合并域名。</p><p><code>减少请求数</code>：JS、CSS打包到HTML。JS控制图片异步加载、懒加载。小型图片使用data-uri。</p><p><code>较少传输体积</code>：尽量使用SVG\gradient代替图片。根据机型和网络状况控制图片清晰度。对低清晰度图片使用锐化来提升体验。设计上避免大型背景图。</p><p><code>使用CDN加速</code>，内容分发网络，是建立再承载网基础上的虚拟分布式网络，能够将源站内容缓存到全国或全球的节点服务器上。用户就近获取内容，提高了资源的访问速度，分担源站压力。</p></div><div class="reward-container"><div>如果觉得文章有帮助，就请吃个雪糕吧~</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/wechatpay.png" alt="很帅很愁人~ 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>很帅很愁人~</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.wy1991.cn/20211110/999-2021%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="131-2021高频面试题">https://blog.wy1991.cn/20211110/999-2021高频面试题/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li><li class="post-copyright-license"><strong>联系方式： </strong>如文章有错误，请联系qq：598204996 谢谢~</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js/" rel="tag"># js</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20211102/130-js%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E5%87%BAexcel/" rel="prev" title="130-js浏览器导出excel"><i class="fa fa-chevron-left"></i> 130-js浏览器导出excel</a></div><div class="post-nav-item"><a href="/20211112/131-%E5%A6%82%E4%BD%95%E7%94%A8-css-%E6%88%96-js-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E6%95%88%E6%9E%9C/" rel="next" title="131-如何用 css 或 js 实现多行文本溢出省略效果">131-如何用 css 或 js 实现多行文本溢出省略效果 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#javascript-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">javascript 基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof"><span class="nav-number">1.1.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof"><span class="nav-number">1.2.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-%E6%98%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%98%E6%98%AF%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">typeof 是操作符还是函数?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-%E5%92%8C-instanceof-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">typeof 和 instanceof 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype-toString-call"><span class="nav-number">1.5.</span> <span class="nav-text">Object.prototype.toString.call()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">javascript 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="nav-number">1.7.</span> <span class="nav-text">&#x3D;&#x3D; 的隐式转换规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">1.8.</span> <span class="nav-text">[“1”,”2”,”3”].map(parseInt)的输出结果是多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="nav-number">1.9.</span> <span class="nav-text">如何判断数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#number-%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E8%8C%83%E5%9B%B4"><span class="nav-number">1.10.</span> <span class="nav-text">number 能表示的整数的最大范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-toFixed-%E4%BC%9A%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C"><span class="nav-number">1.11.</span> <span class="nav-text">2.toFixed() 会输出什么结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.</span> <span class="nav-text">查询某个对象是否有某个属性的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#splice-%E5%92%8C-slice-%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%95%A5%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%E5%90%97"><span class="nav-number">1.13.</span> <span class="nav-text">splice 和 slice 你能说说有啥用和区别吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.</span> <span class="nav-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.</span> <span class="nav-text">JS 中构造函数与普通函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B1%BB%E6%95%B0%E7%BB%84"><span class="nav-number">1.16.</span> <span class="nav-text">类数组与数组区别，为什么要设置类数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-%E4%B8%8E-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.17.</span> <span class="nav-text">null 与 undefined 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-%E6%B7%B1%E5%85%A5%E9%83%A8%E5%88%86"><span class="nav-number">2.</span> <span class="nav-text">JavaScript 深入部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E6%8C%87%E5%90%91"><span class="nav-number">2.1.</span> <span class="nav-text">this 指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">2.2.</span> <span class="nav-text">原型与原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.3.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">谈谈对作用域链的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.5.</span> <span class="nav-text">谈谈你对闭包的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-number">2.6.</span> <span class="nav-text">预编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-number">2.6.1.</span> <span class="nav-text">函数预编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%A2%84%E7%BC%96%E8%AF%91%E5%9B%9B%E9%83%A8%E6%9B%B2"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">函数预编译四部曲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">案例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-number">2.6.2.</span> <span class="nav-text">全局预编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">全局预编译三部曲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-1"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">案例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.6.3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">2.6.4.</span> <span class="nav-text">常见面试题分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">题目一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">题目二</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88"><span class="nav-number">2.6.4.2.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">题目三</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-1"><span class="nav-number">2.6.4.3.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B"><span class="nav-number">2.6.4.4.</span> <span class="nav-text">题目四</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-2"><span class="nav-number">2.6.4.4.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%94"><span class="nav-number">2.6.4.5.</span> <span class="nav-text">题目五</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-3"><span class="nav-number">2.6.4.5.1.</span> <span class="nav-text">答案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.6.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B0%B1%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B"><span class="nav-number">2.7.</span> <span class="nav-text">new 操作符就做了哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97"><span class="nav-number">2.8.</span> <span class="nav-text">你真的了解垃圾回收机制吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E4%B8%8E-Class-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.9.</span> <span class="nav-text">JS 原型链继承与 Class 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-number">2.9.1.</span> <span class="nav-text">基于原型继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Class-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.9.2.</span> <span class="nav-text">基于 Class 继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call%E3%80%81apply%E3%80%81bind-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.10.</span> <span class="nav-text">call、apply、bind 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie-localStorage-sessionStorage-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.11.</span> <span class="nav-text">cookie, localStorage sessionStorage 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%AB%98%E9%98%B6%E6%96%B9%E6%B3%95"><span class="nav-number">2.12.</span> <span class="nav-text">数组高阶方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.13.</span> <span class="nav-text">防抖与节流的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.14.</span> <span class="nav-text">script 标签的 defer 和 async 属性有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%8C%BA%E5%88%AB"><span class="nav-number">2.15.</span> <span class="nav-text">同步任务与异步任务区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.15.1.</span> <span class="nav-text">同步任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.15.2.</span> <span class="nav-text">异步任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">2.15.3.</span> <span class="nav-text">举例说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-new-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%AD%E6%9C%89-return%EF%BC%8C%E9%82%A3%E5%AE%83-return-%E5%87%BA%E6%9D%A5%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.16.</span> <span class="nav-text">使用 new 调用函数，而这个函数中有 return，那它 return 出来的是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.16.1.</span> <span class="nav-text">返回值为基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.16.2.</span> <span class="nav-text">返回值为对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-promise%EF%BC%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-promise"><span class="nav-number">2.17.</span> <span class="nav-text">什么是 promise？实现一个简单的 promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%9B%E5%BC%83%E4%BA%86-Object-definePropetry-%E9%87%87%E7%94%A8-proxy"><span class="nav-number">2.18.</span> <span class="nav-text">vue3 为什么抛弃了 Object.definePropetry 采用 proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C-vuex-%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">2.19.</span> <span class="nav-text">vue 中双向绑定和 vuex 冲突怎么办?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-HTTPS-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">2.20.</span> <span class="nav-text">介绍 HTTPS 握手过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%94%E9%A2%98"><span class="nav-number">2.21.</span> <span class="nav-text">答题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-for-%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94-forEach-%E9%AB%98"><span class="nav-number">2.22.</span> <span class="nav-text">为什么 for 的性能比 forEach 高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JavaScript-Proxy-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">2.23.</span> <span class="nav-text">使用 JavaScript Proxy 实现简单的数据绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%B2%E7%9F%A5%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E6%89%8D%E8%83%BD%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%BA-300px-%EF%BC%9F%E6%B3%A8%E6%84%8F%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="nav-number">2.24.</span> <span class="nav-text">已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BD%91%E5%9D%80"><span class="nav-number">2.25.</span> <span class="nav-text">如何判断输入的是一个正确的网址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-localStorage"><span class="nav-number">2.26.</span> <span class="nav-text">模拟实现一个 localStorage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%B2%E7%9F%A5%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-fn-%E6%89%BE%E5%87%BA%E9%93%BE%E6%9D%A1%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%88%B6%E7%BA%A7-id"><span class="nav-number">2.27.</span> <span class="nav-text">已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if%E3%80%81v-show%E3%80%81v-html-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%9A%84"><span class="nav-number">2.28.</span> <span class="nav-text">v-if、v-show、v-html 的原理是什么，它是如何封装的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input-%E6%90%9C%E7%B4%A2%E5%A6%82%E4%BD%95%E9%98%B2%E6%8A%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5"><span class="nav-number">2.29.</span> <span class="nav-text">input 搜索如何防抖，如何处理中文输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%8F%98%E5%BC%82%E7%9A%84%EF%BC%9F%E4%BE%8B%E5%A6%82-push%E3%80%81pop%E3%80%81splice-%E7%AD%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.30.</span> <span class="nav-text">vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9Fvue-%E9%A6%96%E9%A1%B5%E7%99%BD%E5%B1%8F%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="nav-number">2.31.</span> <span class="nav-text">vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E5%88%86%E6%9E%90%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.31.1.</span> <span class="nav-text">首先分析原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%83%E8%99%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">2.31.2.</span> <span class="nav-text">考虑解决办法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-%E4%B8%AD%E7%9A%84-never-%E7%B1%BB%E5%9E%8B%E5%85%B7%E4%BD%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">2.32.</span> <span class="nav-text">TypeScript 中的 never 类型具体有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">2.33.</span> <span class="nav-text">Vue 中的 computed 和 watch 的区别在哪里</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#computed%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">2.33.1.</span> <span class="nav-text">computed：计算属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#watch%EF%BC%9A%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">2.33.2.</span> <span class="nav-text">watch：监听数据的变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js"><span class="nav-number">2.34.</span> <span class="nav-text">js</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84-arguments-%E6%80%8E%E4%B9%88%E7%94%A8%E6%95%B0%E7%BB%84%E5%BE%97%E6%96%B9%E6%B3%95-push-pop-shift-unshift-%E7%AD%89"><span class="nav-number">2.34.1.</span> <span class="nav-text">类数组 arguments 怎么用数组得方法 push pop shift unshift 等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99-map"><span class="nav-number">2.34.2.</span> <span class="nav-text">手写 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99-every"><span class="nav-number">2.34.3.</span> <span class="nav-text">手写 every</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99-some"><span class="nav-number">2.34.4.</span> <span class="nav-text">手写 some</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1-once"><span class="nav-number">2.35.</span> <span class="nav-text">执行一次 once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F-lodash-%E4%B8%AD%E7%9A%84-flowRight"><span class="nav-number">2.36.</span> <span class="nav-text">模拟 lodash 中的 flowRight</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87"><span class="nav-number">2.37.</span> <span class="nav-text">面试八股文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-%E5%92%8C-HTTPS"><span class="nav-number">2.37.1.</span> <span class="nav-text">1. HTTP 和 HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-http-%E5%92%8C-https-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.37.1.1.</span> <span class="nav-text">1.http 和 https 的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">2.37.1.2.</span> <span class="nav-text">2.http 和 https 的区别及优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-https-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.37.1.3.</span> <span class="nav-text">3.https 协议的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.37.2.</span> <span class="nav-text">TCP三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.37.3.</span> <span class="nav-text">TCP 四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="nav-number">2.37.4.</span> <span class="nav-text">TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.37.5.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">2.37.6.</span> <span class="nav-text">HTTP 请求跨域问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.37.7.</span> <span class="nav-text">Cookie、sessionStorage、localStorage 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96"><span class="nav-number">2.37.8.</span> <span class="nav-text">粘包问题分析与对策</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">2.38.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">2.38.1.</span> <span class="nav-text">从输入URL到页面加载的全过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.38.2.</span> <span class="nav-text">浏览器重绘与重排的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%9F"><span class="nav-number">2.38.3.</span> <span class="nav-text">如何触发重排和重绘？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E7%BB%98%E6%88%96%E8%80%85%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="nav-number">2.38.4.</span> <span class="nav-text">如何避免重绘或者重排？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B304%E8%BF%87%E7%A8%8B"><span class="nav-number">2.38.5.</span> <span class="nav-text">介绍下304过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-amp-amp-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">2.38.6.</span> <span class="nav-text">浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8B%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="nav-number">2.38.7.</span> <span class="nav-text">说下进程、线程和协程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-amp-amp-CSS"><span class="nav-number">2.39.</span> <span class="nav-text">HTML &amp;&amp; CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5-%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="nav-number">2.39.1.</span> <span class="nav-text">HTML5 新特性、语义化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.39.2.</span> <span class="nav-text">CSS 选择器及优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="nav-number">2.39.3.</span> <span class="nav-text">position 属性的值有哪些及其区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#box-sizing%E5%B1%9E%E6%80%A7"><span class="nav-number">2.39.4.</span> <span class="nav-text">box-sizing属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.39.5.</span> <span class="nav-text">CSS 盒子模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC%EF%BC%88%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89"><span class="nav-number">2.39.6.</span> <span class="nav-text">BFC（块级格式上下文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="nav-number">2.39.7.</span> <span class="nav-text">让一个元素水平垂直居中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.39.8.</span> <span class="nav-text">隐藏页面中某个元素的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7"><span class="nav-number">2.39.9.</span> <span class="nav-text">用CSS实现三角符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="nav-number">2.39.10.</span> <span class="nav-text">页面布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Flex-%E5%B8%83%E5%B1%80"><span class="nav-number">2.39.10.1.</span> <span class="nav-text">1.Flex 布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Rem-%E5%B8%83%E5%B1%80"><span class="nav-number">2.39.10.2.</span> <span class="nav-text">2.Rem 布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"><span class="nav-number">2.39.10.3.</span> <span class="nav-text">3.百分比布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="nav-number">2.39.10.4.</span> <span class="nav-text">4.浮动布局</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rem%E6%88%96viewport%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="nav-number">2.39.11.</span> <span class="nav-text">如何使用rem或viewport进行移动端适配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.39.12.</span> <span class="nav-text">清除浮动的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E3%80%81TS%E3%80%81ES6"><span class="nav-number">2.40.</span> <span class="nav-text">JS、TS、ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E4%B8%AD%E7%9A%848%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">2.40.1.</span> <span class="nav-text">JS中的8种数据类型及区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="nav-number">2.40.2.</span> <span class="nav-text">JS中的数据类型检测方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-typeof"><span class="nav-number">2.40.2.1.</span> <span class="nav-text">1.typeof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-instanceof"><span class="nav-number">2.40.2.2.</span> <span class="nav-text">2.instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Object-prototype-toString-call"><span class="nav-number">2.40.2.3.</span> <span class="nav-text">3.Object.prototype.toString.call()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#var-amp-amp-let-amp-amp-const"><span class="nav-number">2.40.3.</span> <span class="nav-text">var &amp;&amp; let &amp;&amp; const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.40.4.</span> <span class="nav-text">JS垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">2.40.5.</span> <span class="nav-text">作用域和作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%A4%E5%A4%A7%E4%BD%9C%E7%94%A8%EF%BC%9A%E4%BF%9D%E5%AD%98-%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.40.6.</span> <span class="nav-text">闭包的两大作用：保存&#x2F;保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E4%B8%AD-this-%E7%9A%84%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">2.40.7.</span> <span class="nav-text">JS 中 this 的五种情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B-amp-amp-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">2.40.8.</span> <span class="nav-text">原型 &amp;&amp; 原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.40.9.</span> <span class="nav-text">new运算符的实现机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.40.10.</span> <span class="nav-text">EventLoop 事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%8E%AF%EF%BC%88Event-Loop"><span class="nav-number">2.40.10.1.</span> <span class="nav-text">浏览器中的事件环（Event Loop)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%8E%AF%EF%BC%88Event-Loop"><span class="nav-number">2.40.10.2.</span> <span class="nav-text">Node 环境中的事件环（Event Loop)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout%E3%80%81Promise%E3%80%81Async-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.40.11.</span> <span class="nav-text">setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async-Await-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5"><span class="nav-number">2.40.12.</span> <span class="nav-text">Async&#x2F;Await 如何通过同步的方式实现异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96%E5%8E%9F%E7%90%86%E3%80%81%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">2.40.13.</span> <span class="nav-text">介绍节流防抖原理、区别以及应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0MVVM"><span class="nav-number">2.40.14.</span> <span class="nav-text">简述MVVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.40.15.</span> <span class="nav-text">Vue底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">2.40.16.</span> <span class="nav-text">谈谈对vue生命周期的理解？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.40.16.1.</span> <span class="nav-text">组件生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computed%E4%B8%8Ewatch"><span class="nav-number">2.40.17.</span> <span class="nav-text">computed与watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">2.40.18.</span> <span class="nav-text">组件中的data为什么是一个函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88v-for%E5%92%8Cv-if%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-number">2.40.19.</span> <span class="nav-text">为什么v-for和v-if不建议用在一起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.40.20.</span> <span class="nav-text">React&#x2F;Vue 项目中 key 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.40.21.</span> <span class="nav-text">vue组件的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.40.22.</span> <span class="nav-text">nextTick的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.40.23.</span> <span class="nav-text">nextTick的实现原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%8F%92%E6%A7%BD%E4%B9%88%EF%BC%9F%E7%94%A8%E7%9A%84%E6%98%AF%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E8%BF%98%E6%98%AF%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD%E6%88%96%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="nav-number">2.40.24.</span> <span class="nav-text">使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keep-alive%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.40.25.</span> <span class="nav-text">keep-alive的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mixin"><span class="nav-number">2.40.26.</span> <span class="nav-text">mixin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.40.27.</span> <span class="nav-text">Vuex的理解及使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E8%81%8A%E8%81%8Areact%E4%B8%ADclass%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.40.28.</span> <span class="nav-text">hooks用过吗？聊聊react中class组件和函数组件的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.40.29.</span> <span class="nav-text">React 组件通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.40.29.1.</span> <span class="nav-text">1）父组件向子组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.40.29.2.</span> <span class="nav-text">2）子组件向父组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.40.29.3.</span> <span class="nav-text">3）跨级组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E9%9D%9E%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">2.40.29.4.</span> <span class="nav-text">4）非嵌套关系的组件通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setState-%E6%97%A2%E5%AD%98%E5%9C%A8%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5%E4%B9%9F%E5%AD%98%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%83%85%E5%86%B5"><span class="nav-number">2.40.30.</span> <span class="nav-text">setState 既存在异步情况也存在同步情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.40.31.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-react-fiber"><span class="nav-number">2.40.32.</span> <span class="nav-text">说一下 react-fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E8%83%8C%E6%99%AF"><span class="nav-number">2.40.32.1.</span> <span class="nav-text">1）背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.40.32.2.</span> <span class="nav-text">2）实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Portals"><span class="nav-number">2.40.33.</span> <span class="nav-text">Portals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%A6%82%E5%92%8C%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">2.40.34.</span> <span class="nav-text">何时要使用异步组件？如和使用异步组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="nav-number">2.40.35.</span> <span class="nav-text">React 事件绑定原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack"><span class="nav-number">2.41.</span> <span class="nav-text">webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack-%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%8C%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%96%B9%E9%9D%A2%E3%80%81%E6%89%93%E5%8C%85%E7%AD%96%E7%95%A5%E6%96%B9%E9%9D%A2%E7%AD%89%E7%AD%89"><span class="nav-number">2.41.1.</span> <span class="nav-text">webpack 做过哪些优化，开发效率方面、打包策略方面等等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Babel"><span class="nav-number">2.42.</span> <span class="nav-text">Babel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-Babel-%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.42.1.</span> <span class="nav-text">简单描述一下 Babel 的编译过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">2.43.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.43.1.</span> <span class="nav-text">Git 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.43.2.</span> <span class="nav-text">如何使用Git管理项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="nav-number">2.43.3.</span> <span class="nav-text">项目优化</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="很帅很愁人~" src="/images/my.jpg"><p class="site-author-name" itemprop="name">很帅很愁人~</p><div class="site-description" itemprop="description">梦是一种欲望, 想是一种行动。梦想是梦与想的结晶，加油打工人~~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">218</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">119</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArryaBuffer/" rel="tag">ArryaBuffer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/" rel="tag">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recorder/" rel="tag">Recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/" rel="tag">TS</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/" rel="tag">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/V8/" rel="tag">V8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueRouter/" rel="tag">VueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuex/" rel="tag">Vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebStorage/" rel="tag">WebStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86/" rel="tag">api集中管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apply/" rel="tag">apply</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios/" rel="tag">axios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bind/" rel="tag">bind</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call/" rel="tag">call</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cli/" rel="tag">cli</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cors/" rel="tag">cors</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/" rel="tag">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/drag/" rel="tag">drag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ejsexcel/" rel="tag">ejsexcel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/element/" rel="tag">element</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel%E5%AF%BC%E5%87%BA/" rel="tag">excel导出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filter/" rel="tag">filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/" rel="tag">flex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getters/" rel="tag">getters</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/host/" rel="tag">host</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/" rel="tag">html5</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jenkins/" rel="tag">jenkins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">84</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag">js基础语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%93%8D%E4%BD%9C%E7%AC%A6/" rel="tag">js操作符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/" rel="tag">lottie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/" rel="tag">media</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/messageChannel/" rel="tag">messageChannel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/miniVue/" rel="tag">miniVue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitt/" rel="tag">mitt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/" rel="tag">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nest/" rel="tag">nest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/print/" rel="tag">print</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/" rel="tag">promise</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recorder/" rel="tag">recorder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ref/" rel="tag">ref</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rem/" rel="tag">rem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/require-context/" rel="tag">require.context</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reuqest/" rel="tag">reuqest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scss/" rel="tag">scss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sessionStorage/" rel="tag">sessionStorage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot/" rel="tag">slot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stackoverflow/" rel="tag">stackoverflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tailwind/" rel="tag">tailwind</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/" rel="tag">tcp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/" rel="tag">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/three/" rel="tag">three</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/utils/" rel="tag">utils</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vueRouter/" rel="tag">vueRouter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex/" rel="tag">vuex</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vw/" rel="tag">vw</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-worker/" rel="tag">web worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E6%89%93%E5%8D%B0/" rel="tag">web打印</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/worker/" rel="tag">worker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlsx/" rel="tag">xlsx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yarn/" rel="tag">yarn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%BF%83/" rel="tag">初心</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB%E5%BA%93/" rel="tag">动画库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型与原型链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" rel="tag">发布订阅</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">多文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B1%8F/" rel="tag">大屏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" rel="tag">媒体查询</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/" rel="tag">字节序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/" rel="tag">封装请求</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/" rel="tag">居中对齐</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E5%BE%97/" rel="tag">心得</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/" rel="tag">性能监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%96%E6%8B%BD/" rel="tag">拖拽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E6%A7%BD/" rel="tag">插槽</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B8%E5%86%8C/" rel="tag">相册</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="tag">移动端常见问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/" rel="tag">脚手架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" rel="tag">自动化部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" rel="tag">自适应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E8%AF%95/" rel="tag">调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/" rel="tag">辅助工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%99%E4%B8%A4%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE/" rel="tag">这两年做过的物联网项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="tag">进程和线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%83%A8%E7%BD%B2/" rel="tag">部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">1</span></li></ul></canvas></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">豫ICP备19017003号-1 </span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://blog.img.wy1991.cn/static/images/ga.png" style="display:inline-block"></div><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">很帅很愁人~</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="/js/local-search.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f65cb40e9a5d20342ae8b58def42ea5f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.name="baidu_tongji";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:null,display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>